{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"FAANG DSA Course","text":"<p>Welcome to the FAANG DSA Course documentation site. </p> <p>This guide covers common Data Structures and Algorithms problems from major tech companies like Google, Amazon, and Microsoft. </p> <p>Use the navigation above or the side menu to explore categorized problems and solutions.</p>"},{"location":"GITHUB_PAGES_SETUP/","title":"GitHub Pages Integration Guide","text":"<p>This guide explains how the documentation for this project is automatically deployed using GitHub Pages and GitHub Actions.</p>"},{"location":"GITHUB_PAGES_SETUP/#automated-deployment-workflow","title":"Automated Deployment Workflow","text":"<p>The project uses a GitHub Action defined in <code>.github/workflows/deploy.yml</code> to automate the deployment process.</p>"},{"location":"GITHUB_PAGES_SETUP/#how-it-works","title":"How it works","text":"<ol> <li>Trigger: Every time you push code to the <code>main</code> branch.</li> <li>Setup: The action installs the <code>uv</code> package manager and Python.</li> <li>Build: It installs all dependencies (like <code>mkdocs-material</code>).</li> <li>Deploy: It runs <code>mkdocs gh-deploy</code> which pushes the built static site to the <code>gh-pages</code> branch.</li> </ol>"},{"location":"GITHUB_PAGES_SETUP/#manual-setup-steps-one-time","title":"Manual Setup Steps (One-time)","text":"<p>To enable the site for the first time:</p> <ol> <li> <p>Commit and Push the Workflow:    <pre><code>git add .github/workflows/deploy.yml\ngit commit -m \"Add GitHub Actions workflow for deployment\"\ngit push origin main\n</code></pre></p> </li> <li> <p>Wait for the Workflow:    Go to your repository on GitHub.com and click the Actions tab. Verify that the <code>deploy-docs</code> workflow finishes successfully.</p> </li> <li> <p>Enable GitHub Pages:</p> <ul> <li>Go to Settings &gt; Pages.</li> <li>Under Build and deployment, set the source to Deploy from a branch.</li> <li>Select the <code>gh-pages</code> branch and the <code>/ (root)</code> folder.</li> <li>Click Save.</li> </ul> </li> <li> <p>Access your site:    The documentation will be live at <code>https://&lt;your-username&gt;.github.io/brass-code-vs-code/</code>.</p> </li> </ol>"},{"location":"GITHUB_PAGES_SETUP/#local-preview","title":"Local Preview","text":"<p>Before pushing, you can always preview your changes locally: <pre><code>uv run mkdocs serve\n</code></pre> This will start a local server, usually at <code>http://127.0.0.1:8000/</code>.</p>"},{"location":"INTERNAL_REFERENCE/","title":"FAANG DSA Course - Problem-to-Method Mapping","text":"<p>This document maps each problem in the topics.md master list to its implementation in the source documentation.</p>"},{"location":"INTERNAL_REFERENCE/#google-problems-1414","title":"Google Problems (14/14)","text":"# Problem Method Link Documentation 1 Two Sum two_sum README 2 Binary Tree Level Order level_order README 3 Longest Substring length_of_longest_substring README 4 Kth Largest Element find_kth_largest README 5 Merge Intervals merge README 6 Search Rotated Array search README 7 Valid Parentheses is_valid_parentheses README 8 Word Ladder ladder_length README 9 Container Water max_area README 10 Subset Sum II subsets_with_dup README 11 Median Data Stream MedianFinder README 12 Min Window Substring min_window README 13 Reverse K Group reverse_k_group README 14 Min Rotated Array find_min README"},{"location":"INTERNAL_REFERENCE/#amazon-problems-1515","title":"Amazon Problems (15/15)","text":"# Problem Method Link Documentation 1 Edit Distance edit_distance README 2 Reverse Linked List reverse_list README 3 Trapping Rain Water trap README 4 Merge K Sorted Lists merge_k_lists README 5 Valid Parentheses is_valid README 6 LRU Cache LRUCache README 7 Top K Frequent top_k_frequent README 8 Zigzag Level Order zigzag_level_order README 9 Min Stack MinStack README 10 Integer to Roman int_to_roman README 11 Subtree of Tree is_subtree README 12 Palindrome List is_palindrome README 13 Reorder Log Files reorder_log_files README 14 Is Substring is_substring README"},{"location":"INTERNAL_REFERENCE/#microsoft-master-list-1515","title":"Microsoft Master List (15/15)","text":"# Problem Method Link Documentation 1 Histogram Area largest_rectangle_area README 2 Linked List Cycle has_cycle README 3 Group Anagrams group_anagrams README 4 Letter Combinations letter_combinations README 5 Valid Sudoku is_valid_sudoku README 6 Word Search word_search README 7 Minimum Depth min_depth README 8 Rotate Array rotate_array README 9 Largest Palindrome longest_palindrome README 10 Combination Sum combination_sum README 11 Valid Palindrome is_valid_palindrome README 12 Delete Node delete_node README 13 Buy/Sell Stock max_profit README 14 Spiral Matrix spiral_order README 15 Right Side View right_side_view README <p>Note: This mapping reflects the 100% completion status of the master transcription in <code>topics.md</code>. Internal reference with code mapping.</p>"},{"location":"MKDOCS_WALKTHROUGH/","title":"MkDocs Integration Walkthrough","text":"<p>This document outlines the setup and customization performed to integrate MkDocs into the FAANG DSA Course project.</p>"},{"location":"MKDOCS_WALKTHROUGH/#setup-details","title":"\ud83d\udee0 Setup Details","text":""},{"location":"MKDOCS_WALKTHROUGH/#1-dependencies","title":"1. Dependencies","text":"<p>We used <code>uv</code> to manage the installation of the following tools: - <code>mkdocs-material</code>: The core theme. - <code>mkdocs-static-i18n</code>: For future internationalization support. - <code>mkdocs-minify-plugin</code>: To optimize the final site output.</p>"},{"location":"MKDOCS_WALKTHROUGH/#2-configuration-mkdocsyml","title":"2. Configuration (<code>mkdocs.yml</code>)","text":"<p>The configuration is optimized for a technical course: - Navigation: Organized by company (Google, Amazon, Microsoft). - Extensions: Enabled Mermaid, Admonitions, and Code Highlighting. - Theme: Material theme with a custom VSCode Dark Modern aesthetic.</p>"},{"location":"MKDOCS_WALKTHROUGH/#theme-customization","title":"\ud83c\udfa8 Theme Customization","text":"<p>The \"VSCode Dark Modern\" look was achieved using CSS variables in <code>docs/stylesheets/extra.css</code>.</p>"},{"location":"MKDOCS_WALKTHROUGH/#color-palette","title":"Color Palette","text":"Element Hex Color Main Background <code>#1f1f1f</code> Sidebar/Header <code>#181818</code> Primary Accent <code>#007acc</code> Code Blocks <code>#1e1e1e</code>"},{"location":"MKDOCS_WALKTHROUGH/#content-migration","title":"\ud83d\udcc2 Content Migration","text":"<ul> <li>Moved <code>topics.md</code> to <code>docs/topics.md</code>.</li> <li>Updated all internal links to be relative to the <code>docs/</code> root.</li> <li>Created <code>docs/index.md</code> as the site homepage.</li> </ul>"},{"location":"MKDOCS_WALKTHROUGH/#verification","title":"\u2705 Verification","text":"<p>The integration was verified by running <code>uv run mkdocs build</code>, ensuring a clean build with functional diagrams and links.</p>"},{"location":"PROBLEM_MAPPING/","title":"FAANG DSA Course - Problem-to-Method Mapping","text":"<p>This document maps each problem in the topics.md master list to its implementation in the source documentation.</p>"},{"location":"PROBLEM_MAPPING/#google-problems-1414","title":"Google Problems (14/14)","text":"# Problem Method Link Documentation 1 Two Sum two_sum README 2 Binary Tree Level Order level_order README 3 Longest Substring length_of_longest_substring README 4 Kth Largest Element find_kth_largest README 5 Merge Intervals merge README 6 Search Rotated Array search README 7 Valid Parentheses is_valid_parentheses README 8 Word Ladder ladder_length README 9 Container Water max_area README 10 Subset Sum II subsets_with_dup README 11 Median Data Stream MedianFinder README 12 Min Window Substring min_window README 13 Reverse K Group reverse_k_group README 14 Min Rotated Array find_min README"},{"location":"PROBLEM_MAPPING/#amazon-problems-1515","title":"Amazon Problems (15/15)","text":"# Problem Method Link Documentation 1 Edit Distance edit_distance README 2 Reverse Linked List reverse_list README 3 Trapping Rain Water trap README 4 Merge K Sorted Lists merge_k_lists README 5 Valid Parentheses is_valid README 6 LRU Cache LRUCache README 7 Top K Frequent top_k_frequent README 8 Zigzag Level Order zigzag_level_order README 9 Min Stack MinStack README 10 Integer to Roman int_to_roman README 11 Subtree of Tree is_subtree README 12 Palindrome List is_palindrome README 13 Reorder Log Files reorder_log_files README 14 Is Substring is_substring README"},{"location":"PROBLEM_MAPPING/#microsoft-master-list-1515","title":"Microsoft Master List (15/15)","text":"# Problem Method Link Documentation 1 Histogram Area largest_rectangle_area README 2 Linked List Cycle has_cycle README 3 Group Anagrams group_anagrams README 4 Letter Combinations letter_combinations README 5 Valid Sudoku is_valid_sudoku README 6 Word Search word_search README 7 Minimum Depth min_depth README 8 Rotate Array rotate_array README 9 Largest Palindrome longest_palindrome README 10 Combination Sum combination_sum README 11 Valid Palindrome is_valid_palindrome README 12 Delete Node delete_node README 13 Buy/Sell Stock max_profit README 14 Spiral Matrix spiral_order README 15 Right Side View right_side_view README <p>Note: This mapping reflects the 100% completion status of the master transcription in <code>topics.md</code>.</p>"},{"location":"RUNNING_GUIDE/","title":"Running the Project Guide","text":"<p>This guide provides detailed instructions on how to run the documentation server, perform linting, and execute tests using <code>uv</code>.</p>"},{"location":"RUNNING_GUIDE/#poe-task-runner-recommended","title":"\u26a1\ufe0f Poe Task Runner (Recommended)","text":"<p>We have integrated <code>poethepoet</code> to streamline project tasks. You can run these commands easily through <code>uv</code>.</p>"},{"location":"RUNNING_GUIDE/#available-tasks","title":"Available Tasks","text":"Task Command Description <code>serve</code> <code>uv run poe serve</code> Start the MkDocs development server <code>build</code> <code>uv run poe build</code> Build the static site into <code>site/</code> <code>test</code> <code>uv run poe test</code> Run all unit tests with <code>pytest</code> <code>lint</code> <code>uv run poe lint</code> Run <code>ruff</code> linter checks <code>format</code> <code>uv run poe format</code> Auto-format code with <code>ruff</code>"},{"location":"RUNNING_GUIDE/#troubleshooting-poe-command-not-found","title":"\ud83d\udee0 Troubleshooting: \"poe: command not found\"","text":"<p>If you try to run <code>poe serve</code> and see <code>zsh: command not found: poe</code>, it is because Poe is installed as a project dependency, not a global system command. </p>"},{"location":"RUNNING_GUIDE/#solution-1-use-uv-run-standard","title":"Solution 1: Use <code>uv run</code> (Standard)","text":"<p>Always prefix the command with <code>uv run</code>. This tells <code>uv</code> to look for the command inside your project's virtual environment. <pre><code>uv run poe serve\n</code></pre></p>"},{"location":"RUNNING_GUIDE/#solution-2-global-installation-optional","title":"Solution 2: Global Installation (Optional)","text":"<p>If you want to be able to use <code>poe</code> directly without the <code>uv run</code> prefix, install it as a global tool using <code>uv</code>: <pre><code>uv tool install poethepoet\n</code></pre></p> <p>[!NOTE] <code>uv tool install</code> safely manages the tool in an isolated environment while making the <code>poe</code> command available globally on your system.</p>"},{"location":"RUNNING_GUIDE/#legacy-project-commands-manual-uv","title":"\ud83c\udfd7 Legacy Project Commands (Manual uv)","text":"<p>If you prefer not to use the task runner, you can still use the direct commands: - MKDocs: <code>uv run mkdocs serve</code> - Linting: <code>uv run ruff check .</code> - Testing: <code>uv run pytest</code></p>"},{"location":"RUNNING_GUIDE/#theming-notes","title":"\ud83c\udfa8 Theming Notes","text":"<p>The project uses a custom VSCode Dark Modern theme.  - Style location: <code>docs/stylesheets/extra.css</code> - Configuration: <code>mkdocs.yml</code></p> <p>If you need to adjust colors or layout, modify <code>extra.css</code>.</p>"},{"location":"topics/","title":"FAANG DSA Questions Transcription","text":"<p>Based on the provided image \"Top DSA Questions at FAANG Companies\", here are the questions categorized by company. Click on a problem name to view its detailed documentation.</p>"},{"location":"topics/#google","title":"Google","text":"<ol> <li>Two Sum</li> <li>Binary Tree Level Order Traversal</li> <li>Longest Substring Without Repeating Characters</li> <li>Kth Largest Element in Array</li> <li>Merge Intervals</li> <li>Search in Rotated Sorted Array</li> <li>Valid Parentheses</li> <li>Word Ladder</li> <li>Container With Most Water</li> <li>Subset Sum II</li> <li>Find Median from Data Stream</li> <li>Minimum Window Substring</li> <li>Reverse Nodes in k-Group</li> <li>Find Minimum in Rotated Sorted Array</li> </ol>"},{"location":"topics/#amazon","title":"Amazon","text":"<ol> <li>Levenshtein Distance / Edit Distance</li> <li>Reverse Linked List</li> <li>Trapping Rain Water</li> <li>Merge K Sorted Lists</li> <li>Valid Parentheses</li> <li>LRU Cache</li> <li>Top K Frequent Elements</li> <li>Binary Tree Zigzag Level Order Traversal</li> <li>Min Stack</li> <li>Integer to Roman</li> <li>Subtree of Another Tree</li> <li>Palindrome Linked List</li> <li>Reorder Data in Log Files</li> <li>Check If a String is a Substring of Another String</li> </ol>"},{"location":"topics/#microsoft","title":"Microsoft","text":"<ol> <li>Largest Rectangle in Histogram</li> <li>Linked List Cycle</li> <li>Group Anagrams</li> <li>Letter Combinations of a Phone Number</li> <li>Valid Sudoku</li> <li>Word Search</li> <li>Minimum Depth of Binary Tree</li> <li>Rotate Array</li> <li>Largest Palindromic Substring</li> <li>Combination Sum</li> <li>Valid Palindrome</li> <li>Delete Node in a Linked List</li> <li>Best Time to Buy and Sell Stock</li> <li>Spiral Matrix</li> <li>Binary Tree Right Side View</li> </ol>"},{"location":"amazon/","title":"Amazon DSA Problems","text":"<p>This section contains solutions for common DSA problems asked in Amazon interviews.</p> <p>Use the sidebar or the Problem Mapping to find specific solutions.</p>"},{"location":"amazon/01_edit_distance/","title":"Levenshtein Distance / Edit Distance \ud83d\udd34 Hard","text":"<p>Tags: <code>Dynamic Programming</code>, <code>String</code></p>"},{"location":"amazon/01_edit_distance/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Dynamic Programming (2D) \ud83d\udd34 Hard Critical Building solution from subproblems"},{"location":"amazon/01_edit_distance/#the-challenge","title":"The Challenge","text":"<p>Given two strings <code>word1</code> and <code>word2</code>, return the minimum number of operations required to convert <code>word1</code> to <code>word2</code>.</p>"},{"location":"amazon/01_edit_distance/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: This is the core algorithm behind spell checkers, DNA sequence alignment, and diff tools (like <code>git</code>).</p> Scenario Preferred Approach Why? General Case Dynamic Programming Guarantees minimum operations in $O(M \\times N)$. Space Constraint DP with Row Optimization Reduces space from $O(M \\times N)$ to $O(min(M,N))$ by keeping only previous row. Real-Time Search Trie / BK-Tree For fuzzy search against millions of words, standard DP is too slow. <p>Constraints: - $0 \\leq word1.length, word2.length \\leq 500$ - <code>word1</code> and <code>word2</code> consist of lowercase English letters.</p> <p>Example: <pre><code>Input: word1 = \"horse\", word2 = \"ros\"\nOutput: 3\nExplanation: \nhorse -&gt; rorse (replace 'h' with 'r')\nrorse -&gt; rose (remove 'r')\nrose -&gt; ros (remove 'e')\n</code></pre></p>"},{"location":"amazon/01_edit_distance/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/01_edit_distance/#naive-approach-recursion","title":"Naive Approach (Recursion)","text":"<p>Try 3 operations at every step. - Complexity: $O(3^N)$. - Fail: Redundant calculations (overlapping subproblems).</p>"},{"location":"amazon/01_edit_distance/#optimal-approach-2d-dp","title":"Optimal Approach (2D DP)","text":"<p>Use a table <code>dp[i][j]</code> representing min cost to convert <code>word1[0...i]</code> to <code>word2[0...j]</code>. - Transitions:     - If <code>w1[i] == w2[j]</code>: <code>dp[i][j] = dp[i-1][j-1]</code> (No op).     - Else: <code>1 + min(Insert, Delete, Replace)</code>         - Insert: <code>dp[i][j-1]</code> (convert to w2[j-1], then append char)         - Delete: <code>dp[i-1][j]</code> (delete w1[i], then convert rest)         - Replace: <code>dp[i-1][j-1]</code> (swap char)</p>"},{"location":"amazon/01_edit_distance/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(M \\times N)$ Fill table of size $M \\times N$. Space $O(M \\times N)$ Table storage. Can be optimized to $O(min(M,N))$."},{"location":"amazon/01_edit_distance/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Transform \"hor\" to \"ro\".</p> <p><pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Start[\"DP Table Init\"] --&gt; Fill[\"dp[i][j] calculation\"]\n    Fill --&gt; Cell[\"match 'r' == 'r'? No.\"]\n    Cell --&gt; Op[\"Min(Ins, Del, Rep) + 1\"]\n\n    Op --&gt; End[\"dp[3][2] = Cost\"]\n    class End primary</code></pre> (Simplified due to table complexity)</p>"},{"location":"amazon/01_edit_distance/#solution","title":"Solution","text":"<pre><code>def min_distance(self, word1: str, word2: str) -&gt; int:\n    m, n = len(word1), len(word2)\n    dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n    for i in range(m + 1): dp[i][0] = i\n    for j in range(n + 1): dp[0][j] = j\n\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if word1[i - 1] == word2[j - 1]:\n                dp[i][j] = dp[i - 1][j - 1]\n            else:\n                dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n\n    return dp[m][n]\n</code></pre>"},{"location":"amazon/02_reverse_linked_list/","title":"Reverse Linked List \ud83d\udfe2 Easy","text":"<p>Tags: <code>Linked List</code>, <code>Recursion</code></p>"},{"location":"amazon/02_reverse_linked_list/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Pointer Manipulation \ud83d\udfe2 Easy Critical Safely rewiring next pointers"},{"location":"amazon/02_reverse_linked_list/#the-challenge","title":"The Challenge","text":"<p>Given the head of a singly linked list, reverse the list, and return the reversed list.</p>"},{"location":"amazon/02_reverse_linked_list/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: A fundamental operation in data structure manipulation, often a subroutine in complex problems (e.g., Palindrome Check, Add Numbers).</p> Scenario Preferred Approach Why? Standard Iterative $O(N)$ Time and $O(1)$ Space. Robust and simple. Functional/Immutable Recursive Fits functional paradigms but risks Stack Overflow on large lists ($N &gt; 1000$ in Python). Memory Constrained Iterative Avoids recursion stack overhead. <p>Constraints: - Number of nodes in range $[0, 5000]$. - $-5000 \\leq Node.val \\leq 5000$</p> <p>Example: <pre><code>Input: head = [1,2,3,4,5]\nOutput: [5,4,3,2,1]\n</code></pre></p>"},{"location":"amazon/02_reverse_linked_list/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/02_reverse_linked_list/#naive-approach","title":"Naive Approach","text":"<p>Copy values to array, reverse array, create new list. - Space: $O(N)$.</p>"},{"location":"amazon/02_reverse_linked_list/#optimal-approach-iterative","title":"Optimal Approach (Iterative)","text":"<p>Three pointers: <code>prev</code>, <code>curr</code>, <code>next_node</code>. - Logic:     1. Save <code>next_node = curr.next</code>.     2. Reverse link: <code>curr.next = prev</code>.     3. Shift: <code>prev = curr</code>, <code>curr = next_node</code>.</p>"},{"location":"amazon/02_reverse_linked_list/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass. Space $O(1)$ Constant extra variables."},{"location":"amazon/02_reverse_linked_list/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>1 -&gt; 2 -&gt; 3</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"Prev: None, Curr: 1\"] --&gt; Step1[\"1.next -&gt; None. Prev: 1, Curr: 2\"]\n    class Step1 primary\n\n    Step1 --&gt; Step2[\"2.next -&gt; 1. Prev: 2, Curr: 3\"]\n    Step2 --&gt; Step3[\"3.next -&gt; 2. Prev: 3, Curr: None\"]\n\n    Step3 --&gt; Done[\"Return Prev (3)\"]\n    class Done success</code></pre>"},{"location":"amazon/02_reverse_linked_list/#solution","title":"Solution","text":"<pre><code>def reverse_list(self, head: ListNode | None) -&gt; ListNode | None:\n    prev = None\n    curr = head\n    while curr:\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n    return prev\n</code></pre>"},{"location":"amazon/03_trapping_rain_water/","title":"Trapping Rain Water \ud83d\udd34 Hard","text":"<p>Tags: <code>Array</code>, <code>Two Pointers</code>, <code>Stack</code>, <code>Dynamic Programming</code></p>"},{"location":"amazon/03_trapping_rain_water/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Two Pointers \ud83d\udfe1 Medium Critical Moving inward based on height"},{"location":"amazon/03_trapping_rain_water/#the-challenge","title":"The Challenge","text":"<p>Given <code>n</code> non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it can trap after raining.</p>"},{"location":"amazon/03_trapping_rain_water/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Key problem for understanding \"Pre-computation\" vs \"Two Pointers\" trade-offs. Applications in terrain analysis and histograms.</p> Scenario Preferred Approach Why? Standard Two Pointers $O(N)$ Time, $O(1)$ Space. Optimal. Easy to Implement Prefix Max Arrays $O(N)$ Space, but logic is trivial (min(max_left, max_right) - height). Stream Data Stack Can handle elements arriving one by one (monotonic stack). <p>Constraints: - $n == height.length$ - $1 \\leq n \\leq 2 \\times 10^4$ - $0 \\leq height[i] \\leq 10^5$</p> <p>Example: <pre><code>Input: height = [0,1,0,2,1,0,1,3,2,1,2,1]\nOutput: 6\n</code></pre></p>"},{"location":"amazon/03_trapping_rain_water/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/03_trapping_rain_water/#naive-approach","title":"Naive Approach","text":"<p>For each bar, find max left and max right. <code>Water = min(max_L, max_R) - height</code>. - Complexity: $O(N^2)$. - Fail: TLE.</p>"},{"location":"amazon/03_trapping_rain_water/#optimal-approach-two-pointers","title":"Optimal Approach (Two Pointers)","text":"<p>Maintain <code>left_max</code> and <code>right_max</code>. - Key Insight: Water level at any point is determined by the shorter of the two bounding walls (left vs right). - Strategy:     1. If <code>height[left] &lt; height[right]</code>:         - Update <code>left_max</code>.         - We KNOW there is a right wall (at <code>right</code>) taller than <code>left_max</code> (otherwise we wouldn't be here). So water is determined by <code>left_max</code>.         - <code>Water += left_max - height[left]</code>.         - <code>left++</code>.     2. Else:         - Symmetric logic for right side.</p>"},{"location":"amazon/03_trapping_rain_water/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass. Space $O(1)$ Pointers only."},{"location":"amazon/03_trapping_rain_water/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[4, 2, 0, 3, 2, 5]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"L:0 (4), R:5 (5)\"] --&gt; Branch[\"L(4) &lt; R(5)? Yes.\"]\n    Branch --&gt; Comp[\"L_Max(4). Water += 4-4=0\"]\n    Comp --&gt; MoveL[\"L -&gt; 1 (2)\"]\n\n    MoveL --&gt; Branch2[\"L(2) &lt; R(5)? Yes.\"]\n    Branch2 --&gt; Comp2[\"L_Max(4). Water += 4-2=2\"]\n    class Comp2 primary\n\n    Comp2 --&gt; MoveL2[\"L -&gt; 2 (0)\"]\n    MoveL2 --&gt; Comp3[\"L_Max(4). Water += 4-0=4\"]\n    class Comp3 success</code></pre>"},{"location":"amazon/03_trapping_rain_water/#solution","title":"Solution","text":"<pre><code>def trap(self, height: list[int]) -&gt; int:\n    if not height: return 0\n    left, right = 0, len(height) - 1\n    left_max, right_max = height[left], height[right]\n    water = 0\n    while left &lt; right:\n        if left_max &lt; right_max:\n            left += 1\n            left_max = max(left_max, height[left])\n            water += left_max - height[left]\n        else:\n            right -= 1\n            right_max = max(right_max, height[right])\n            water += right_max - height[right]\n    return water\n</code></pre>"},{"location":"amazon/04_merge_k_sorted_lists/","title":"Merge k Sorted Lists \ud83d\udd34 Hard","text":"<p>Tags: <code>Heap</code>, <code>Linked List</code>, <code>Divide and Conquer</code></p>"},{"location":"amazon/04_merge_k_sorted_lists/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Min-Heap (Priority Queue) \ud83d\udfe1 Medium Critical Efficiently selecting minimum of K heads Linked List Pointers \ud83d\udfe2 Easy High Building the result list"},{"location":"amazon/04_merge_k_sorted_lists/#the-challenge","title":"The Challenge","text":"<p>You are given an array of <code>k</code> linked-lists <code>lists</code>, each linked-list is sorted in ascending order.</p> <p>Merge all the linked-lists into one sorted linked-list and return it.</p>"},{"location":"amazon/04_merge_k_sorted_lists/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: This is exactly how massive scale database sorts (External Merge Sort) work when data doesn't fit in memory.</p> Scenario Preferred Approach Why? General ($K$ large) Min-Heap $O(N \\log K)$. Efficiently tracks the minimum of K streams. Standard Sort Collect &amp; Sort If everything fits in array, Python's Timsort ($O(N \\log N)$) is highly optimized and often faster in practice due to C implementation, despite worse theoretical complexity for small K. Iterative Merge Pairwise merging 2 at a time is $O(N \\times K)$. Slow. <p>Constraints: - $k == lists.length$ - $0 \\leq k \\leq 10^4$ - $0 \\leq lists[i].length \\leq 500$ - $-10^4 \\leq lists[i][j] \\leq 10^4$ - <code>lists[i]</code> is sorted. - sum of lengths $\\leq 10^4$.</p> <p>Example: <pre><code>Input: lists = [[1,4,5],[1,3,4],[2,6]]\nOutput: [1,1,2,3,4,4,5,6]\n</code></pre></p>"},{"location":"amazon/04_merge_k_sorted_lists/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/04_merge_k_sorted_lists/#naive-approach","title":"Naive Approach","text":"<p>Collect all nodes into a list, sort them, rebuild list. - Complexity: $O(N \\log N)$ where $N$ is total nodes. Space $O(N)$.</p>"},{"location":"amazon/04_merge_k_sorted_lists/#optimal-approach-min-heap","title":"Optimal Approach (Min-Heap)","text":"<p>Keep the head of every list in a Min-Heap. - Logic:     1. Push head of each of the <code>k</code> lists into heap.     2. Pop min element (smallest current head). Append to result list.     3. If the popped node has a next node, push it to heap.     4. Repeat until heap empty. - Comparison: This is like \"Merge Sort\" merge step but for K lists.</p>"},{"location":"amazon/04_merge_k_sorted_lists/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\log k)$ Heap size is at most $k$. $N$ insertions/deletions. Space $O(k)$ Heap stores 1 node per list."},{"location":"amazon/04_merge_k_sorted_lists/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>L1: 1-&gt;4</code>, <code>L2: 2-&gt;3</code>, <code>L3: 5</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"Heap: [1(L1), 2(L2), 5(L3)]\"] --&gt; Pop[\"Pop 1. Result: 1. &lt;br/&gt; Add L1.next (4)\"]\n    Pop --&gt; H2[\"Heap: [2(L2), 4(L1), 5(L3)]\"]\n    class Pop primary\n\n    H2 --&gt; Pop2[\"Pop 2. Result: 1-&gt;2 &lt;br/&gt; Add L2.next (3)\"]\n    Pop2 --&gt; H3[\"Heap: [3(L2), 4(L1), 5(L3)]\"]\n\n    H3 --&gt; Pop3[\"Pop 3. Result: 1-&gt;2-&gt;3 &lt;br/&gt; L2 Done.\"]\n    Pop3 --&gt; H4[\"Heap: [4(L1), 5(L3)]\"]</code></pre>"},{"location":"amazon/04_merge_k_sorted_lists/#solution","title":"Solution","text":"<pre><code>def merge_k_lists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n    heap = []\n    # Store (val, idx, node) to handle tie-breaking without node comparison\n    for i, node in enumerate(lists):\n        if node:\n            heapq.heappush(heap, (node.val, i, node))\n\n    dummy = ListNode()\n    curr = dummy\n\n    while heap:\n        val, i, node = heapq.heappop(heap)\n        curr.next = node\n        curr = curr.next\n\n        if node.next:\n            heapq.heappush(heap, (node.next.val, i, node.next))\n\n    return dummy.next\n</code></pre>"},{"location":"amazon/05_valid_parentheses/","title":"Valid Parentheses \ud83d\udfe2 Easy","text":"<p>Tags: <code>Stack</code>, <code>String</code></p>"},{"location":"amazon/05_valid_parentheses/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Stack Operations \ud83d\udfe2 Easy Critical LIFO property"},{"location":"amazon/05_valid_parentheses/#the-challenge","title":"The Challenge","text":"<p>Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p>"},{"location":"amazon/05_valid_parentheses/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: The basis of compilers, parsers (JSON/XML), and code editors (bracket matching).</p> Scenario Preferred Approach Why? Standard Stack $O(N)$ Time. LIFO perfectly matches nested structure nature. Memory Extreme Counter Only possible if single bracket type <code>()</code>. If multiple types, stack is mandatory to track order. <p>Constraints: - $1 \\leq s.length \\leq 10^4$</p> <p>Example: <pre><code>Input: s = \"()[]{}\"\nOutput: true\n</code></pre></p>"},{"location":"amazon/05_valid_parentheses/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/05_valid_parentheses/#optimal-approach-stack","title":"Optimal Approach (Stack)","text":"<p>Standard stack-based matching. - Logic: Push open brackets. When close bracket appears, pop and check match. - Complexity: $O(N)$ Time, $O(N)$ Space.</p>"},{"location":"amazon/05_valid_parentheses/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>(]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef error fill:#ef4444,stroke:#f87171,stroke-width:2px,color:#ffffff\n\n    Start[\"Stack: []\"] --&gt; Push[\"Push '('. Stack: ['(']\"]\n    Push --&gt; Check[\"Char ']'. Matches '('? No.\"]\n    class Check error\n\n    Check --&gt; Fail[\"Return False\"]</code></pre>"},{"location":"amazon/05_valid_parentheses/#solution","title":"Solution","text":"<pre><code>def is_valid(self, s: str) -&gt; bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n    for char in s:\n        if char in mapping:\n            top = stack.pop() if stack else '#'\n            if mapping[char] != top:\n                return False\n        else:\n            stack.append(char)\n    return not stack\n</code></pre>"},{"location":"amazon/06_lru_cache/","title":"LRU Cache \ud83d\udd34 Hard","text":"<p>Tags: <code>Design</code>, <code>Hash Table</code>, <code>Linked List</code>, <code>Doubly Linked List</code></p>"},{"location":"amazon/06_lru_cache/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Hash Map \ud83d\udfe2 Easy Critical O(1) Key access Doubly Linked List \ud83d\udfe1 Medium Critical O(1) Remove/Move"},{"location":"amazon/06_lru_cache/#the-challenge","title":"The Challenge","text":"<p>Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.</p> <p>Implement the <code>LRUCache</code> class: - <code>LRUCache(int capacity)</code> Initialize the LRU cache with positive size <code>capacity</code>. - <code>int get(int key)</code> Return the value of the <code>key</code> if the key exists, otherwise return <code>-1</code>. - <code>void put(int key, int value)</code> Update the value of the <code>key</code> if the <code>key</code> exists. Otherwise, add the <code>key-value</code> pair to the cache. If the number of keys exceeds the <code>capacity</code> from this operation, evict the least recently used key.</p> <p>The functions <code>get</code> and <code>put</code> must each run in $O(1)$ average time complexity.</p> <p>Constraints: - $1 \\leq capacity \\leq 3000$ - $0 \\leq key \\leq 10^4$ - $0 \\leq value \\leq 10^5$</p> <p>Example: <pre><code>cache = LRUCache(2)\ncache.put(1, 1)\ncache.put(2, 2)\ncache.get(1)       # returns 1\ncache.put(3, 3)    # evicts key 2\ncache.get(2)       # returns -1 (not found)\n</code></pre></p>"},{"location":"amazon/06_lru_cache/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/06_lru_cache/#naive-approach","title":"Naive Approach","text":"<p>List of tuples <code>(key, val, time)</code>. Sort by time on eviction. - Complexity: $O(N)$ due to search/delete.</p>"},{"location":"amazon/06_lru_cache/#optimal-approach-hashmap-dll","title":"Optimal Approach (HashMap + DLL)","text":"<p>Combine HashMap (fast lookup) with Doubly Linked List (fast ordering). - HashMap: Stores <code>key -&gt; Node</code>. - DLL: Maintains order.     - Head: Most Recently Used (MRU).     - Tail: Least Recently Used (LRU). - Logic:     - <code>get(k)</code>: Look up node. Move to Head. Return val.     - <code>put(k, v)</code>:         - If exists: Update val. Move to Head.         - If new: Create node. Add to Head. Add to Map.         - If capacity full: Remove Tail node. Remove from Map.</p>"},{"location":"amazon/06_lru_cache/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: The \"Hello World\" of system design caching layers (Redis, Memcached).</p> Scenario Preferred Approach Why? Standard Cache LRU (Hash+DLL) Simple, effective for temporal locality (recently used = likely used again). Frequency Matters LFU (Min-Heap) If \"popular\" items matter more than \"recent\" ones (e.g., DNS records). Simple/Small FIFO (Queue) If exact eviction policy matters less than simple implementation."},{"location":"amazon/06_lru_cache/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(1)$ Hash lookup &amp; pointer swaps are constant time. Space $O(N)$ Storing N nodes and N map entries."},{"location":"amazon/06_lru_cache/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Capacity 2. <code>put(1,1)</code>, <code>put(2,2)</code>, <code>get(1)</code>.</p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"Head &lt;-&gt; Tail\"] --&gt; Put1[\"Head &lt;-&gt; [1,1] &lt;-&gt; Tail\"]\n    Put1 --&gt; Put2[\"Head &lt;-&gt; [2,2] &lt;-&gt; [1,1] &lt;-&gt; Tail\"]\n\n    Put2 --&gt; Get1[\"Get(1). Move [1,1] to Head.\"]\n    Get1 --&gt; State3[\"Head &lt;-&gt; [1,1] &lt;-&gt; [2,2] &lt;-&gt; Tail\"]\n    class State3 primary\n\n    State3 --&gt; Put3[\"Put(3,3). Evict Tail ([2,2]). Add [3,3].\"]\n    Put3 --&gt; Final[\"Head &lt;-&gt; [3,3] &lt;-&gt; [1,1] &lt;-&gt; Tail\"]\n    class Final success</code></pre>"},{"location":"amazon/06_lru_cache/#solution","title":"Solution","text":"<pre><code>class LRUCache:\n    class Node:\n        def __init__(self, key, val):\n            self.key = key\n            self.val = val\n            self.prev = None\n            self.next = None\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}\n        self.head = self.Node(0, 0)\n        self.tail = self.Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add(self, node):\n        prev_node = self.tail.prev\n        prev_node.next = node\n        node.prev = prev_node\n        node.next = self.tail\n        self.tail.prev = node\n\n    def get(self, key: int) -&gt; int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add(node)\n            return node.val\n        return -1\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            self._remove(self.cache[key])\n        node = self.Node(key, value)\n        self._add(node)\n        self.cache[key] = node\n\n        if len(self.cache) &gt; self.capacity:\n            lru = self.head.next\n            self._remove(lru)\n            del self.cache[lru.key]\n</code></pre>"},{"location":"amazon/07_top_k_frequent/","title":"Top K Frequent Elements \ud83d\udfe1 Medium","text":"<p>Tags: <code>Heap</code>, <code>Hash Table</code>, <code>Sorting</code></p>"},{"location":"amazon/07_top_k_frequent/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Hash Map (Frequency) \ud83d\udfe2 Easy Critical Counting occurrences Min-Heap (K size) \ud83d\udfe1 Medium High Keep top K efficiently"},{"location":"amazon/07_top_k_frequent/#the-challenge","title":"The Challenge","text":"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the <code>k</code> most frequent elements. You may return the answer in any order.</p> <p>Constraints: - $1 \\leq nums.length \\leq 10^5$ - <code>k</code> is in the range <code>[1, the number of unique elements in the array]</code>. - It is guaranteed that the answer is unique.</p> <p>Example: <pre><code>Input: nums = [1,1,1,2,2,3], k = 2\nOutput: [1,2]\n</code></pre></p>"},{"location":"amazon/07_top_k_frequent/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/07_top_k_frequent/#naive-approach","title":"Naive Approach","text":"<p>Count frequencies, sort by frequency. - Complexity: $O(N \\log N)$ (sorting). - Good enough?: Often yes, but $O(N \\log K)$ is better if $N$ huge and $K$ small.</p>"},{"location":"amazon/07_top_k_frequent/#optimal-approach-min-heap-bucket-sort","title":"Optimal Approach (Min-Heap / Bucket Sort)","text":"<ol> <li>Hash Map: Count freq $O(N)$.</li> <li>Min-Heap: Keep size $K$.<ul> <li>Push <code>(freq, num)</code>.</li> <li>If size &gt; K, Pop min.</li> <li>Remaining K are the largest.</li> <li>Complexity: $O(N \\log K)$.</li> </ul> </li> <li>Bucket Sort (O(N)):<ul> <li>Freq can be at most N.</li> <li>Array <code>buckets[freq] = [nums]</code>.</li> <li>Iterate buckets from N down to 1. Collect K nums.</li> </ul> </li> </ol>"},{"location":"amazon/07_top_k_frequent/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Analyzing logs (top IP addresses), Trending Topics (hashtags), Recommender Systems.</p> Scenario Preferred Approach Why? Streaming Data Min-Heap (Size K) Can process infinite stream, only storing K items in memory. Bounded Input Bucket Sort $O(N)$ is strictly better than $O(N \\log K)$ if we know max frequency $\\leq N$. Simple Sorting Python's <code>Counter.most_common(k)</code> uses <code>heapq.nlargest</code> internally ($O(N \\log K)$)."},{"location":"amazon/07_top_k_frequent/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\log k)$ Heap operations. Space $O(N)$ Hash Map storage."},{"location":"amazon/07_top_k_frequent/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[1,1,1, 2,2, 3]</code>, <code>k=2</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Count[\"Map: {1:3, 2:2, 3:1}\"] --&gt; Heap[\"Heap Push (3, 1), (2, 2)\"]\n    Heap --&gt; Push3[\"Heap Push (1, 3) -&gt; Size 3 &gt; K\"]\n\n    Push3 --&gt; Pop[\"Pop Min (1, 3). Heap: [(2,2), (3,1)]\"]\n    Pop --&gt; Result[\"Return keys: [1, 2]\"]\n    class Result success</code></pre>"},{"location":"amazon/07_top_k_frequent/#solution","title":"Solution","text":"<pre><code>def top_k_frequent(self, nums: list[int], k: int) -&gt; list[int]:\n    count = Counter(nums)\n    return heapq.nlargest(k, count.keys(), key=count.get)\n</code></pre>"},{"location":"amazon/08_zigzag_level_order/","title":"Binary Tree Zigzag Level Order Traversal \ud83d\udfe1 Medium","text":"<p>Tags: <code>Tree</code>, <code>BFS</code></p>"},{"location":"amazon/08_zigzag_level_order/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes BFS (Level Order) \ud83d\udfe2 Easy Critical Core logic Deque Operations \ud83d\udfe2 Easy High Efficient front/back appending"},{"location":"amazon/08_zigzag_level_order/#the-challenge","title":"The Challenge","text":"<p>Given the <code>root</code> of a binary tree, return the zigzag level order traversal of its nodes' values. (i.e., from left to right, then right to left for the next level and alternate between).</p> <p>Constraints: - Number of nodes in range $[0, 2000]$.</p> <p>Example: <pre><code>Input: root = [3,9,20,null,null,15,7]\nOutput: [[3],[20,9],[15,7]]\n</code></pre></p>"},{"location":"amazon/08_zigzag_level_order/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/08_zigzag_level_order/#optimal-approach-bfs-deque","title":"Optimal Approach (BFS + Deque)","text":"<p>Standard BFS but control insertion direction. - Logic: Use a flag <code>left_to_right</code>.     - If <code>True</code>: Append to tail of level list.     - If <code>False</code>: Append to head (or reverse list at end).     - Toggle flag after each level.</p>"},{"location":"amazon/08_zigzag_level_order/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: UI rendering patterns (Z-scan), specific network routing topologies.</p> Scenario Preferred Approach Why? Standard BFS + Deque $O(N)$ Time. Efficiently builds level lists without post-reversal. Alternative Two Stacks Use 2 stacks to simulate order reversal, but BFS is more idiomatic for \"level\" tasks."},{"location":"amazon/08_zigzag_level_order/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Visit each node once. Space $O(N)$ Queue stores max width of tree (N/2)."},{"location":"amazon/08_zigzag_level_order/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[3, 9, 20]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Q[\"Q: [3]\"] --&gt; L1[\"Pop 3. Dir: L-&gt;R. Res: [3]\"]\n    L1 --&gt; Add[\"Add 9, 20. Q: [9, 20]. Toggle Dir.\"]\n\n    Add --&gt; L2[\"Pop 9, 20. Dir: R-&gt;L.\"]\n    L2 --&gt; Res2[\"Res: [3], [20, 9] (20 then 9 or reverse list)\"]\n    class Res2 success</code></pre>"},{"location":"amazon/08_zigzag_level_order/#solution","title":"Solution","text":"<pre><code>def zigzag_level_order(self, root: TreeNode | None) -&gt; list[list[int]]:\n    if not root: return []\n    results = []\n    queue = deque([root])\n    left_to_right = True\n\n    while queue:\n        level_size = len(queue)\n        current_level = deque()\n        for _ in range(level_size):\n            node = queue.popleft()\n            if left_to_right:\n                current_level.append(node.val)\n            else:\n                current_level.appendleft(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        results.append(list(current_level))\n        left_to_right = not left_to_right\n    return results\n</code></pre>"},{"location":"amazon/09_median_two_sorted_arrays/","title":"Median of Two Sorted Arrays \ud83d\udd34 Hard","text":"<p>Tags: <code>Array</code>, <code>Binary Search</code>, <code>Divide and Conquer</code></p>"},{"location":"amazon/09_median_two_sorted_arrays/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Binary Search \ud83d\udfe2 Easy Critical Finding partition point"},{"location":"amazon/09_median_two_sorted_arrays/#the-challenge","title":"The Challenge","text":"<p>Given two sorted arrays <code>nums1</code> and <code>nums2</code> of size <code>m</code> and <code>n</code> respectively, return the median of the two sorted arrays.</p> <p>The overall run time complexity should be $O(\\log (m+n))$.</p> <p>Constraints: - $nums1.length == m$ - $nums2.length == n$ - $0 \\leq m \\leq 1000$ - $0 \\leq n \\leq 1000$ - $1 \\leq m + n \\leq 2000$</p> <p>Example: <pre><code>Input: nums1 = [1,3], nums2 = [2]\nOutput: 2.0\nExplanation: merged array = [1,2,3] and median is 2.\n</code></pre></p>"},{"location":"amazon/09_median_two_sorted_arrays/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/09_median_two_sorted_arrays/#naive-approach","title":"Naive Approach","text":"<p>Merge arrays ($O(M+N)$), find middle. - Fail: Violates $O(\\log (M+N))$ complexity constraint.</p>"},{"location":"amazon/09_median_two_sorted_arrays/#optimal-approach-bin-search-on-partition","title":"Optimal Approach (Bin Search on Partition)","text":"<p>Find a partition in <code>nums1</code> (size $M$) and <code>nums2</code> (size $N$) such that left half contains same # of elements as right half, and <code>max(Left) &lt;= min(Right)</code>. - Search Space: Cut indices of smaller array ($0$ to $M$). - Conditions: <code>L1 &lt;= R2</code> and <code>L2 &lt;= R1</code>.     - If <code>L1 &gt; R2</code>: Cut too far right. Move Left.     - If <code>L2 &gt; R1</code>: Cut too far left. Move Right.</p>"},{"location":"amazon/09_median_two_sorted_arrays/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Distributed databases (calculating stats across shards) without merging.</p> Scenario Preferred Approach Why? Standard Bin Search (Partition) $O(\\log(\\min(M,N)))$. Fastest possible. Uneven Sizes Bin Search Searching on the smaller array ($M \\ll N$) is extremely fast."},{"location":"amazon/09_median_two_sorted_arrays/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(\\log(\\min(M, N)))$ BS on smaller array. Space $O(1)$ No extra storage."},{"location":"amazon/09_median_two_sorted_arrays/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>N1=[1,3], N2=[2]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"BS on N1. Range [0, 2]\"] --&gt; Try[\"Cut=1. L1=1, R1=3. | L2=2, R2=Inf\"]\n    Try --&gt; Check[\"L1(1) &lt;= R2(Inf)? Yes. L2(2) &lt;= R1(3)? Yes.\"]\n    class Check primary\n\n    Check --&gt; Calc[\"MaxLeft = max(1,2)=2. MinRight = min(3, Inf)=3\"]\n    Calc --&gt; Odd[\"Total Odd -&gt; MaxLeft = 2\"]\n    class Odd success</code></pre>"},{"location":"amazon/09_median_two_sorted_arrays/#solution","title":"Solution","text":"<pre><code>def find_median_sorted_arrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n    if len(nums1) &gt; len(nums2): nums1, nums2 = nums2, nums1\n    m, n = len(nums1), len(nums2)\n    start, end = 0, m\n\n    while start &lt;= end:\n        partition1 = (start + end) // 2\n        partition2 = (m + n + 1) // 2 - partition1\n\n        max_left1 = float('-inf') if partition1 == 0 else nums1[partition1 - 1]\n        min_right1 = float('inf') if partition1 == m else nums1[partition1]\n\n        max_left2 = float('-inf') if partition2 == 0 else nums2[partition2 - 1]\n        min_right2 = float('inf') if partition2 == n else nums2[partition2]\n\n        if max_left1 &lt;= min_right2 and max_left2 &lt;= min_right1:\n            if (m + n) % 2 == 0:\n                return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2.0\n            else:\n                return max(max_left1, max_left2)\n        elif max_left1 &gt; min_right2:\n            end = partition1 - 1\n        else:\n            start = partition1 + 1\n    raise ValueError(\"Not sorted\")\n</code></pre>"},{"location":"amazon/09_min_stack/","title":"Min Stack \ud83d\udfe2 Easy","text":"<p>Tags: <code>Stack</code>, <code>Design</code></p>"},{"location":"amazon/09_min_stack/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Stack Operations \ud83d\udfe2 Easy Critical LIFO principle Auxiliary Space \ud83d\udfe2 Easy High Tracking minimums"},{"location":"amazon/09_min_stack/#the-challenge","title":"The Challenge","text":"<p>Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.</p> <p>Constraints: - $-2^{31} \\leq val \\leq 2^{31} - 1$ - Methods <code>pop</code>, <code>top</code> and <code>getMin</code> operations will always be called on non-empty stacks.</p> <p>Example: <pre><code>minStack = MinStack()\nminStack.push(-2)\nminStack.push(0)\nminStack.push(-3)\nminStack.getMin() # return -3\nminStack.pop()\nminStack.top()    # return 0\nminStack.getMin() # return -2\n</code></pre></p>"},{"location":"amazon/09_min_stack/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/09_min_stack/#optimal-approach-two-stacks","title":"Optimal Approach (Two Stacks)","text":"<p>We use a primary stack for values and an auxiliary \"min stack\" to keep track of the minimum value at each state. - Push: Add to primary stack. If value $\\leq$ current min, add to min stack. - Pop: If popped value == current min, pop from min stack too. - GetMin: Return top of min stack.</p>"},{"location":"amazon/09_min_stack/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(1)$ All operations are constant time. Space $O(N)$ Additional stack to store minimums."},{"location":"amazon/09_min_stack/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"Push -2: Val[-2], Min[-2]\"] --&gt; Step2[\"Push 0: Val[-2, 0], Min[-2]\"]\n    Step2 --&gt; Step3[\"Push -3: Val[-2, 0, -3], Min[-2, -3]\"]\n    Step3 --&gt; GetMin[\"getMin() -&gt; -3\"]\n    class GetMin success</code></pre>"},{"location":"amazon/09_min_stack/#solution","title":"Solution","text":"<pre><code>class MinStack:\n    def __init__(self):\n        self.stack = []\n        self.min_stack = []\n\n    def push(self, val: int) -&gt; None:\n        self.stack.append(val)\n        if not self.min_stack or val &lt;= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -&gt; None:\n        if self.stack.pop() == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -&gt; int:\n        return self.stack[-1]\n\n    def get_min(self) -&gt; int:\n        return self.min_stack[-1]\n</code></pre>"},{"location":"amazon/10_find_median_data_stream/","title":"Find Median from Data Stream \ud83d\udd34 Hard","text":"<p>Tags: <code>Heap</code>, <code>Design</code>, <code>Data Stream</code></p>"},{"location":"amazon/10_find_median_data_stream/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Priority Queue (Heap) \ud83d\udfe1 Medium Critical Maintaining sorted halves efficienty Object-Oriented Design \ud83d\udfe2 Easy High Class structure"},{"location":"amazon/10_find_median_data_stream/#the-challenge","title":"The Challenge","text":"<p>Implement <code>MedianFinder</code> class to add numbers and find median efficiently.</p>"},{"location":"amazon/10_find_median_data_stream/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Analytics dashboards (P50 latency), Senor Data processing.</p> Scenario Preferred Approach Why? Streaming Two Heaps $O(\\log N)$ Insert, $O(1)$ Read. Perfect for real-time. Fixed Range Count Sort / Bucket If integers in range [0, 100], just count them. Partition-based selection is also option but slower for continuous queries."},{"location":"amazon/10_find_median_data_stream/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(\\log N)$ Heap push/pop. Space $O(N)$ Storing all elements."},{"location":"amazon/10_find_median_data_stream/#solution","title":"Solution","text":"<pre><code>class MedianFinder:\n    def __init__(self):\n        self.small = []  # Max-heap (inverted)\n        self.large = []  # Min-heap\n\n    def add_num(self, num: int) -&gt; None:\n        heapq.heappush(self.small, -num)\n        if self.small and self.large and (-self.small[0] &gt; self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.small) &gt; len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) &gt; len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def find_median(self) -&gt; float:\n        if len(self.small) &gt; len(self.large):\n            return float(-self.small[0])\n        return (-self.small[0] + self.large[0]) / 2.0\n</code></pre>"},{"location":"amazon/10_integer_to_roman/","title":"Integer to Roman \ud83d\udfe1 Medium","text":"<p>Tags: <code>Math</code>, <code>String</code>, <code>Greedy</code></p>"},{"location":"amazon/10_integer_to_roman/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Roman Numerals \ud83d\udfe2 Easy Critical Understanding symbols (I, V, X, L, C, D, M) Greedy Algorithm \ud83d\udfe2 Easy High Always taking the largest symbol possible"},{"location":"amazon/10_integer_to_roman/#the-challenge","title":"The Challenge","text":"<p>Convert an integer to a Roman numeral string.</p> <p>Constraints: - $1 \\leq num \\leq 3999$</p> <p>Example: <pre><code>Input: num = 1994\nOutput: \"MCMXCIV\"\nExplanation: M = 1000, CM = 900, XC = 90, IV = 4.\n</code></pre></p>"},{"location":"amazon/10_integer_to_roman/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/10_integer_to_roman/#optimal-approach-greedy","title":"Optimal Approach (Greedy)","text":"<p>Define a mapping of values to Roman numeral symbols in descending order (including subtractive cases like 900 being CM). - Strategy: Iterate through the mapping. While <code>num</code> is $\\geq$ current value, append the symbol and subtract the value from <code>num</code>. - Why it works: Roman numerals are naturally greedy; we use the largest symbols first.</p>"},{"location":"amazon/10_integer_to_roman/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(1)$ Finite number of symbols (max 3999). Space $O(1)$ Result string is small."},{"location":"amazon/10_integer_to_roman/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Start(\"num = 58\") --&gt; M(\"Check 1000...50: Yes (L)\")\n    M --&gt; Rem(\"num = 8\")\n    Rem --&gt; V(\"Check 10...5: Yes (V)\")\n    V --&gt; III(\"num = 3. Add III\")\n    III --&gt; End(\"Result: LVIII\")\n    class End primary</code></pre>"},{"location":"amazon/10_integer_to_roman/#solution","title":"Solution","text":"<pre><code>def int_to_roman(self, num: int) -&gt; str:\n    val_map = [\n        (1000, \"M\"), (900, \"CM\"), (500, \"D\"), (400, \"CD\"),\n        (100, \"C\"), (90, \"XC\"), (50, \"L\"), (40, \"XL\"),\n        (10, \"X\"), (9, \"IX\"), (5, \"V\"), (4, \"IV\"), (1, \"I\")\n    ]\n    roman = []\n    for val, symbol in val_map:\n        while num &gt;= val:\n            roman.append(symbol)\n            num -= val\n    return \"\".join(roman)\n</code></pre>"},{"location":"amazon/11_subtree_another_tree/","title":"Subtree of Another Tree \ud83d\udfe2 Easy","text":"<p>Tags: <code>Tree</code>, <code>DFS</code>, <code>String Matching</code></p>"},{"location":"amazon/11_subtree_another_tree/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Tree Traversal (DFS) \ud83d\udfe2 Easy Critical Navigating both trees Recursion \ud83d\udfe2 Easy Critical Base cases"},{"location":"amazon/11_subtree_another_tree/#the-challenge","title":"The Challenge","text":"<p>Given the roots of two binary trees <code>root</code> and <code>subRoot</code>, return <code>true</code> if there is a subtree of <code>root</code> with the same structure and node values as <code>subRoot</code> and <code>false</code> otherwise.</p> <p>Constraints: - Number of nodes in <code>root</code> $\\leq 2000$. - Number of nodes in <code>subRoot</code> $\\leq 1000$.</p> <p>Example: <pre><code>Input: root = [3,4,5,1,2], subRoot = [4,1,2]\nOutput: true\n</code></pre></p>"},{"location":"amazon/11_subtree_another_tree/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/11_subtree_another_tree/#naive-approach-omn","title":"Naive Approach (O(M*N))","text":"<p>For every node in <code>root</code>, check if the subtree rooted there is identical to <code>subRoot</code>. - <code>is_same</code> check takes $O(M)$ where $M$ is nodes in <code>subRoot</code>. - We do this for $N$ nodes in <code>root</code>. - Total: $O(M \\times N)$.</p>"},{"location":"amazon/11_subtree_another_tree/#optimal-approach-merkle-hashing-string-serialize","title":"Optimal Approach (Merkle Hashing / String Serialize)","text":"<p>Serialize both trees to strings (e.g., Pre-order with null markers). Check if <code>subRoot</code> string is substring of <code>root</code> string. - Complexity: $O(M+N)$ (KMP for substring check). - Trade-off: Requires $O(M+N)$ space for strings.</p>"},{"location":"amazon/11_subtree_another_tree/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Filesystem hierarchy checks, DOM tree manipulation.</p> Scenario Preferred Approach Why? Standard DFS (Naive) $O(M \\times N)$ is fine for $N=2000$. Logic is simplest. Large Scale Merkle Hash Compute hash of every subtree. Compare hashes in $O(1)$. Total $O(M+N)$."},{"location":"amazon/11_subtree_another_tree/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(M \\times N)$ Worst case (skewed trees). Space $O(N)$ Recursion stack height."},{"location":"amazon/11_subtree_another_tree/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>Root: [3,4,5]</code>, <code>Sub: [4]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Start[\"Check(3, 4)? No.\"] --&gt; Left[\"Check(4, 4)?\"]\n    Left --&gt; Same[\"IsSame(4, 4)? Yes.\"]\n    class Same success</code></pre>"},{"location":"amazon/11_subtree_another_tree/#solution","title":"Solution","text":"<pre><code>def is_subtree(self, root: TreeNode | None, subRoot: TreeNode | None) -&gt; bool:\n    if not root: return False\n    if self._is_same_tree(root, subRoot): return True\n    return self.is_subtree(root.left, subRoot) or self.is_subtree(root.right, subRoot)\n\ndef _is_same_tree(self, p: TreeNode | None, q: TreeNode | None) -&gt; bool:\n    if not p and not q: return True\n    if not p or not q or p.val != q.val: return False\n    return self._is_same_tree(p.left, q.left) and self._is_same_tree(p.right, q.right)\n</code></pre>"},{"location":"amazon/12_palindrome_linked_list/","title":"Palindrome Linked List \ud83d\udfe2 Easy","text":"<p>Tags: <code>Linked List</code>, <code>Two Pointers</code></p>"},{"location":"amazon/12_palindrome_linked_list/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Fast &amp; Slow Pointers \ud83d\udfe2 Easy Critical Finding middle List Reversal \ud83d\udfe2 Easy Critical Modifying second half"},{"location":"amazon/12_palindrome_linked_list/#the-challenge","title":"The Challenge","text":"<p>Given the <code>head</code> of a singly linked list, return <code>true</code> if it is a palindrome or <code>false</code> otherwise.</p> <p>Constraints: - Number of nodes in range $[1, 10^5]$. - $O(N)$ time and $O(1)$ space.</p> <p>Example: <pre><code>Input: head = [1,2,2,1]\nOutput: true\n</code></pre></p>"},{"location":"amazon/12_palindrome_linked_list/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/12_palindrome_linked_list/#naive-approach","title":"Naive Approach","text":"<p>Copy to array <code>vals = []</code>. Check <code>vals == vals[::-1]</code>. - Space: $O(N)$. Violation of challenge constraint.</p>"},{"location":"amazon/12_palindrome_linked_list/#optimal-approach-reverse-second-half","title":"Optimal Approach (Reverse Second Half)","text":"<ol> <li>Find middle (Fast/Slow pointers).</li> <li>Reverse second half of list.</li> <li>Compare first half vs reversed second half.</li> <li>(Optional) Restore list.</li> </ol>"},{"location":"amazon/12_palindrome_linked_list/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Memory-constrained environments where allocating $O(N)$ buffer is forbidden.</p> Scenario Preferred Approach Why? Strict Constraints Reverse Half $O(1)$ Space. The only way to meet constraints. Simplicity Array Copy If memory allows, copying is 2 lines of code vs 20."},{"location":"amazon/12_palindrome_linked_list/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Two passes (find mid, reverse/check). Space $O(1)$ Manipulating pointers in place."},{"location":"amazon/12_palindrome_linked_list/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>[1, 2, 2, 1]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"1 -&gt; 2 -&gt; 2 -&gt; 1\"] --&gt; Mid[\"Find Mid: Split at 2nd '2'.\"]\n    Mid --&gt; Rev[\"Reverse 2nd Half: 1 -&gt; 2. AND 1 -&gt; 2\"]\n    Rev --&gt; Comp[\"Compare: 1==1? Yes. 2==2? Yes.\"]\n    class Comp success</code></pre>"},{"location":"amazon/12_palindrome_linked_list/#solution","title":"Solution","text":"<pre><code>def is_palindrome(self, head: ListNode | None) -&gt; bool:\n    if not head or not head.next: return True\n\n    # 1. Find middle\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n\n    # 2. Reverse second half\n    prev = None\n    curr = slow\n    while curr:\n        temp = curr.next\n        curr.next = prev\n        prev = curr\n        curr = temp\n\n    # 3. Compare halves\n    left, right = head, prev\n    while right:\n        if left.val != right.val: return False\n        left = left.next\n        right = right.next\n    return True\n</code></pre>"},{"location":"amazon/13_reorder_log_files/","title":"Reorder Data in Log Files \ud83d\udfe1 Medium","text":"<p>Tags: <code>String</code>, <code>Sorting</code></p>"},{"location":"amazon/13_reorder_log_files/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Sorting with Keys \ud83d\udfe2 Easy Critical Custom comparator logic String Manipulation \ud83d\udfe2 Easy High Parsing identifiers"},{"location":"amazon/13_reorder_log_files/#the-challenge","title":"The Challenge","text":"<p>You are given an array of <code>logs</code>. Each log is a space-delimited string of words, where the first word is the identifier.</p> <p>There are two types of logs: 1. Letter-logs: All words (except the identifier) consist of lowercase English letters. 2. Digit-logs: All words (except the identifier) consist of digits.</p> <p>Reorder these logs so that: 1. The letter-logs come before all digit-logs. 2. The letter-logs are sorted lexicographically by their contents. If their contents are the same, then sort them lexicographically by their identifiers. 3. The digit-logs maintain their relative ordering.</p> <p>Constraints: - $1 \\leq logs.length \\leq 100$ - $3 \\leq logs[i].length \\leq 100$</p> <p>Example: <pre><code>Input: logs = [\"dig1 8 1 5 1\",\"let1 art can\",\"dig2 3 6\",\"let2 own kit dig\",\"let3 art zero\"]\nOutput: [\"let1 art can\",\"let3 art zero\",\"let2 own kit dig\",\"dig1 8 1 5 1\",\"dig2 3 6\"]\n</code></pre></p>"},{"location":"amazon/13_reorder_log_files/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/13_reorder_log_files/#optimal-approach-custom-sort-key","title":"Optimal Approach (Custom Sort Key)","text":"<p>Python's <code>sort</code> is stable, which helps with digit logs if we processed them together, but splitting them is easier. - Strategy:     1. Separate <code>letter</code> and <code>digit</code> logs.     2. Sort <code>letter</code> logs.         - Key: <code>(content, identifier)</code>.     3. Concatenate <code>sorted_letter + digit</code>.</p>"},{"location":"amazon/13_reorder_log_files/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Log aggregation systems (Splunk/ELK), sorting prioritized tasks.</p> Scenario Preferred Approach Why? Standard Split &amp; Sort $O(N \\log N)$. Easiest to read and maintain. In-place Partition Like QuickSort partition (move letters to front), then sort front. Harder to implement stability for digits."},{"location":"amazon/13_reorder_log_files/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\cdot M \\cdot \\log N)$ Sort N logs of max length M. Comparison takes O(M). Space $O(N \\cdot M)$ Storage for split lists."},{"location":"amazon/13_reorder_log_files/#solution","title":"Solution","text":"<pre><code>def reorder_log_files(self, logs: list[str]) -&gt; list[str]:\n    letter_logs = []\n    digit_logs = []\n\n    for log in logs:\n        # split(maxsplit=1) -&gt; [id, content]\n        id_, content = log.split(\" \", 1)\n        if content[0].isalpha():\n            letter_logs.append((content, id_, log))\n        else:\n            digit_logs.append(log)\n\n    # Sort letter logs by content, then id\n    letter_logs.sort(key=lambda x: (x[0], x[1]))\n\n    return [x[2] for x in letter_logs] + digit_logs\n</code></pre>"},{"location":"amazon/14_is_substring/","title":"Check If a String is a Substring \ud83d\udfe2 Easy","text":"<p>Tags: <code>String</code>, <code>Two Pointers</code>, <code>String Matching</code></p>"},{"location":"amazon/14_is_substring/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes String Slicing \ud83d\udfe2 Easy High Extracting subsegments Pattern Matching \ud83d\udfe1 Medium Moderate KMP/Rabin-Karp (advanced)"},{"location":"amazon/14_is_substring/#the-challenge","title":"The Challenge","text":"<p>Given two strings <code>s</code> and <code>t</code>, return the index of the first occurrence of <code>t</code> in <code>s</code>, or <code>-1</code> if <code>t</code> is not part of <code>s</code>.</p> <p>Constraints: - $1 \\leq s.length, t.length \\leq 10^4$ - <code>s</code> and <code>t</code> consist of only lowercase English characters.</p> <p>Example: <pre><code>Input: s = \"sadbutsad\", t = \"sad\"\nOutput: 0\nExplanation: \"sad\" occurs at index 0 and 6. The first occurrence is at 0.\n</code></pre></p>"},{"location":"amazon/14_is_substring/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/14_is_substring/#naive-approach-sliding-window","title":"Naive Approach (Sliding Window)","text":"<p>Check every window of length <code>len(t)</code> in <code>s</code>. - Time Complexity: $O(N \\times M)$ where $N$ is length of <code>s</code> and $M$ is length of <code>t</code>. - Verdict: Sufficient for $N, M \\leq 10^4$ in most cases, but $O(N+M)$ is possible using KMP.</p>"},{"location":"amazon/14_is_substring/#optimal-approach-kmp-overview","title":"Optimal Approach (KMP - Overview)","text":"<p>The Knuth-Morris-Pratt algorithm avoids re-scanning characters by using a partial match table (LPS array). - Key Insight: If we fail a match, we know because of the pattern's properties where the next valid match could start.</p>"},{"location":"amazon/14_is_substring/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\times M)$ Simple implementation using slicing. Space $O(1)$ No extra space beyond result."},{"location":"amazon/14_is_substring/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Start[\"s: 'leetcode', t: 'code'\"] --&gt; Window1[\"Check 'leet' == 'code'? No\"]\n    Window1 --&gt; Window2[\"Check 'eetc' == 'code'? No\"]\n    Window2 --&gt; Match[\"Check 'code' == 'code'? Yes!\"]\n    Match --&gt; Res[\"Return index 4\"]\n    class Res primary</code></pre>"},{"location":"amazon/14_is_substring/#solution","title":"Solution","text":"<pre><code>def is_substring(self, s: str, t: str) -&gt; int:\n    if not t: return 0\n    n, m = len(s), len(t)\n    for i in range(n - m + 1):\n        if s[i : i + m] == t:\n            return i\n    return -1\n</code></pre>"},{"location":"amazon/14_word_search_ii/","title":"Word Search II \ud83d\udd34 Hard","text":"<p>Tags: <code>Trie</code>, <code>Backtracking</code>, <code>DFS</code></p>"},{"location":"amazon/14_word_search_ii/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Trie (Prefix Tree) \ud83d\udfe1 Medium Critical Efficient prefix checking Backtracking \ud83d\udfe1 Medium Critical Exploring board paths"},{"location":"amazon/14_word_search_ii/#the-challenge","title":"The Challenge","text":"<p>Given an <code>m x n</code> <code>board</code> of characters and a list of strings <code>words</code>, return all words on the board.</p> <p>Each word must be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.</p> <p>Constraints: - $m == board.length$, $n == board[i].length$ - $1 \\leq m, n \\leq 12$ - $1 \\leq words.length \\leq 3 \\times 10^4$</p> <p>Example: <pre><code>Input: board = [[\"o\",\"a\",\"a\",\"n\"],[\"e\",\"t\",\"a\",\"e\"],[\"i\",\"h\",\"k\",\"r\"],[\"i\",\"f\",\"l\",\"v\"]], words = [\"oath\",\"pea\",\"eat\",\"rain\"]\nOutput: [\"eat\",\"oath\"]\n</code></pre></p>"},{"location":"amazon/14_word_search_ii/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"amazon/14_word_search_ii/#naive-approach","title":"Naive Approach","text":"<p>For each word, run DFS on board. - Complexity: $O(W \\cdot M \\cdot N \\cdot 4^L)$ where $W$ is words, $L$ is word length. - Fail: Redundant paths (e.g., \"oat\" visited for \"oath\" and \"oats\").</p>"},{"location":"amazon/14_word_search_ii/#optimal-approach-trie-dfs","title":"Optimal Approach (Trie + DFS)","text":"<p>Build a Trie of all words. Run DFS on board once. - Logic:     1. Insert all words into Trie.     2. Iterate every cell $(r, c)$. Start DFS.     3. At each step, check if current path exists in Trie.     4. If Trie node has a \"Word End\" marker, add to results.     5. Optimization: Prune Trie nodes when matched to avoid re-finding.</p>"},{"location":"amazon/14_word_search_ii/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Bogle solvers, Scrabble AI, Phone contact search.</p> Scenario Preferred Approach Why? Many Words Trie + DFS Compresses common prefixes. Efficient. Few Words DFS per Word Simple loop might be faster due to Trie overhead if $W &lt; 5$."},{"location":"amazon/14_word_search_ii/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(M \\cdot N \\cdot 4^L)$ Traverse board ($MN$), explore paths ($4^L$). Trie interaction is $O(1)$. Space $O(W \\cdot L)$ Trie storage."},{"location":"amazon/14_word_search_ii/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Board: <code>o, a</code> ... Word: <code>oath</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Start[\"Scan (0,0) 'o'\"] --&gt; Trie[\"Trie has 'o'? Yes.\"]\n    Trie --&gt; Move[\"Move (0,1) 'a'. Trie has 'o'-&gt;'a'? Yes.\"]\n    Move --&gt; Move2[\"Move (1,2) 't'. Trie has 't'? Yes.\"]\n\n    Move2 --&gt; Move3[\"Move (1,3) 'h'. End Key found.\"]\n    Move3 --&gt; Add[\"Add 'oath'. Prune Leaf.\"]\n    class Add success</code></pre>"},{"location":"amazon/14_word_search_ii/#solution","title":"Solution","text":"<pre><code>def find_words(self, board: list[list[str]], words: list[str]) -&gt; list[str]:\n    WORD_KEY = '$'\n    trie = {}\n    for word in words:\n        node = trie\n        for letter in word:\n            node = node.setdefault(letter, {})\n        node[WORD_KEY] = word\n\n    row_num, col_num = len(board), len(board[0])\n    matched_words = []\n\n    def backtracking(row, col, parent):\n        letter = board[row][col]\n        curr_node = parent[letter]\n\n        # Check for match\n        if WORD_KEY in curr_node:\n            matched_words.append(curr_node[WORD_KEY])\n            del curr_node[WORD_KEY] # Prevent duplicate adds\n\n        board[row][col] = '#' # mark visited\n\n        for r_offset, c_offset in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n            new_r, new_c = row + r_offset, col + c_offset\n            if 0 &lt;= new_r &lt; row_num and 0 &lt;= new_c &lt; col_num and board[new_r][new_c] in curr_node:\n                backtracking(new_r, new_c, curr_node)\n\n        board[row][col] = letter # backtrack\n\n        # Optimization: Prune empty nodes\n        if not curr_node:\n            del parent[letter]\n\n    for r in range(row_num):\n        for c in range(col_num):\n            if board[r][c] in trie:\n                backtracking(r, c, trie)\n\n    return matched_words\n</code></pre>"},{"location":"google/","title":"Google DSA Problems","text":"<p>This section contains solutions for common DSA problems asked in Google interviews.</p> <p>Use the sidebar or the Problem Mapping to find specific solutions.</p>"},{"location":"google/01_two_sum/","title":"Two Sum \ud83d\udfe2 Easy","text":"<p>Tags: <code>Array</code>, <code>Hash Map</code></p>"},{"location":"google/01_two_sum/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Hash Map Operations \ud83d\udfe2 Easy Critical O(1) lookups are key to optimal solution Array Iteration \ud83d\udfe2 Easy High Foundation for traversing inputs"},{"location":"google/01_two_sum/#the-challenge","title":"The Challenge","text":"<p>Given an array of integers <code>nums</code> and an integer <code>target</code>, return indices of the two numbers such that they add up to <code>target</code>.</p> <p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p> <p>Constraints: - $2 \\leq nums.length \\leq 10^4$ - $-10^9 \\leq nums[i] \\leq 10^9$ - $-10^9 \\leq target \\leq 10^9$ - Only one valid answer exists.</p> <p>Example: <pre><code>Input: nums = [2, 7, 11, 15], target = 9\nOutput: [0, 1]\nExplanation: nums[0] + nums[1] = 2 + 7 = 9\n</code></pre></p>"},{"location":"google/01_two_sum/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/01_two_sum/#naivebrute-force","title":"Naive/Brute Force","text":"<p>The intuitive approach is to check every pair of numbers. - Method: Use a nested loop. Outer loop picks <code>nums[i]</code>, inner loop checks <code>nums[j]</code> where <code>j &gt; i</code>. - Failure: Time complexity is $O(N^2)$.     - For $N=10^4$, operations $\\approx 10^8$, which borders on Time Limit Exceeded (TLE) in stricter environments (usually ~10^8 ops/sec).     - Inefficient compared to linear time.</p>"},{"location":"google/01_two_sum/#optimal-approach-hash-map","title":"Optimal Approach (Hash Map)","text":"<p>Instead of scanning for the complement repeatedly, we can \"remember\" what we've seen. - Key Insight: Logic <code>a + b = target</code> can be rewritten as <code>a = target - b</code>. - Strategy: As we iterate through <code>nums</code>, for each number <code>x</code>, we check if <code>target - x</code> exists in our history. - Data Structure: A Hash Map (Dictionary) stores <code>value -&gt; index</code> for $O(1)$ access. - Flow:     1. Initialize empty dict <code>seen</code>.     2. Iterate <code>i, num</code> in inputs.     3. Calc <code>complement = target - num</code>.     4. If <code>complement</code> in <code>seen</code>, return <code>[seen[complement], i]</code>.     5. Else, add <code>num -&gt; i</code> to <code>seen</code>.</p>"},{"location":"google/01_two_sum/#trade-offs","title":"Trade-offs","text":"<ul> <li>Hash Map: Uses $O(N)$ space to achieve $O(N)$ time.</li> <li>Sorting: If we sorted first ($O(N \\log N)$), we could use Two Pointers.<ul> <li>Cons: Indices are lost during sorting (need extra space/logic to track original indices).</li> <li>Pros: Less space ($O(1)$ or $O(\\log N)$ depending on sort) if map overhead is high.</li> <li>Verdict: Hash Map is standard for unsorted arrays needing index returns.</li> </ul> </li> </ul>"},{"location":"google/01_two_sum/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass through the array. Hash map lookups are avg $O(1)$. Space $O(N)$ In worst case (no solution found until end), map stores $N$ elements."},{"location":"google/01_two_sum/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n    classDef warning fill:#f59e0b,stroke:#fbbf24,stroke-width:2px,color:#0f172a\n\n    Start(\"Start Iteration\") --&gt; Check{\"Is complement &lt;br/&gt; in Map?\"}\n    class Start primary\n\n    Check -- No --&gt; Store[\"Store num -&gt; index &lt;br/&gt;in Map\"]\n    class Store warning\n\n    Store --&gt; Next[\"Next Element\"]\n    Next --&gt; Check\n\n    Check -- Yes --&gt; Found[\"Return [seen[complement], i]\"]\n    class Found success</code></pre>"},{"location":"google/01_two_sum/#solution","title":"Solution","text":"<pre><code>def two_sum(self, nums: list[int], target: int) -&gt; list[int]:\n    # Dictionary to store mapping: value -&gt; index\n    seen: dict[int, int] = {}\n\n    for i, num in enumerate(nums):\n        complement = target - num\n        if complement in seen:\n            return [seen[complement], i]\n        seen[num] = i\n    return []\n</code></pre>"},{"location":"google/02_binary_tree_level_order_traversal/","title":"Binary Tree Level Order Traversal \ud83d\udfe1 Medium","text":"<p>Tags: <code>Tree</code>, <code>Breadth-First Search</code>, <code>Queue</code></p>"},{"location":"google/02_binary_tree_level_order_traversal/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Queue Operations \ud83d\udfe2 Easy Critical FIFO property essential for level order Tree Traversal \ud83d\udfe2 Easy High Understanding of node structure"},{"location":"google/02_binary_tree_level_order_traversal/#the-challenge","title":"The Challenge","text":"<p>Given the <code>root</code> of a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).</p> <p>Constraints: - The number of nodes in the tree is in the range $[0, 2000]$. - $-1000 \\leq Node.val \\leq 1000$</p> <p>Example: <pre><code>Input: root = [3,9,20,null,null,15,7]\nOutput: [[3],[9,20],[15,7]]\n</code></pre></p>"},{"location":"google/02_binary_tree_level_order_traversal/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/02_binary_tree_level_order_traversal/#naive-approach","title":"Naive Approach","text":"<p>A depth-first search (DFS) can reach all nodes, but grouping them by level requires passing a <code>level</code> index and maintaining a list of lists. - DFS: Works, but strictly speaking, Level Order is BFS. - Recursion: Can hit stack depth limits for skewed trees (though constraints here are small).</p>"},{"location":"google/02_binary_tree_level_order_traversal/#optimal-approach-bfs","title":"Optimal Approach (BFS)","text":"<p>Use a Queue to process nodes level by level. - Key Insight: We can process all nodes currently in the queue (which represent one level), add their children to the back, and repeat. - Algorithm:     1. Initialize <code>queue</code> with <code>root</code>.     2. While <code>queue</code> is not empty:         a. Get <code>level_size = len(queue)</code>.         b. Loop <code>level_size</code> times:             i. Pop node.             ii. Add val to current level list.             iii. Add children (left, right) to queue.         c. Add current level list to results. - Data Structure: <code>collections.deque</code> for $O(1)$ popleft.</p>"},{"location":"google/02_binary_tree_level_order_traversal/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Each node is processed exactly once. Space $O(N)$ In worst case (perfect binary tree), the last level contains $N/2$ nodes."},{"location":"google/02_binary_tree_level_order_traversal/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Q[\"Queue: [3]\"] --&gt; Pop[\"Pop 3\"]\n    Pop --&gt; Add[\"Add 9, 20 to Queue\"]\n    Add --&gt; Q2[\"Queue: [9, 20]\"]\n    class Q primary\n\n    Q2 --&gt; Pop2[\"Pop 9 &lt;br/&gt; Pop 20\"]\n    Pop2 --&gt; Add2[\"Add children of 20: 15, 7\"]\n    Add2 --&gt; Q3[\"Queue: [15, 7]\"]\n    class Q3 success</code></pre>"},{"location":"google/02_binary_tree_level_order_traversal/#solution","title":"Solution","text":"<pre><code>def level_order(self, root: TreeNode | None) -&gt; list[list[int]]:\n    if not root:\n        return []\n    results = []\n    queue = deque([root])\n    while queue:\n        level_values = []\n        for _ in range(len(queue)):\n            node = queue.popleft()\n            level_values.append(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n        results.append(level_values)\n    return results\n</code></pre>"},{"location":"google/03_longest_substring/","title":"Longest Substring Without Repeating Characters \ud83d\udfe1 Medium","text":"<p>Tags: <code>String</code>, <code>Sliding Window</code>, <code>Hash Table</code></p>"},{"location":"google/03_longest_substring/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Sliding Window \ud83d\udfe1 Medium Critical Core technique for subarray/substring problems Hash Map Operations \ud83d\udfe2 Easy High Used for O(1) character index lookups Two Pointers \ud83d\udfe2 Easy High Managing window boundaries"},{"location":"google/03_longest_substring/#the-challenge","title":"The Challenge","text":"<p>Given a string <code>s</code>, find the length of the longest substring without repeating characters.</p> <p>Constraints: - $0 \\leq s.length \\leq 5 * 10^4$ - <code>s</code> consists of English letters, digits, symbols and spaces.</p> <p>Example: <pre><code>Input: s = \"abcabcbb\"\nOutput: 3\nExplanation: The answer is \"abc\", with the length of 3.\n</code></pre></p>"},{"location":"google/03_longest_substring/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/03_longest_substring/#naivebrute-force","title":"Naive/Brute Force","text":"<p>Check every possible substring to see if it has duplicates. - Method: Nested loops to generate all substrings ($O(N^2)$), then check uniqueness ($O(N)$). - Failure: Complexity $O(N^3)$, or $O(N^2)$ with optimization. Too slow for $N=50,000$.</p>"},{"location":"google/03_longest_substring/#optimal-approach-sliding-window","title":"Optimal Approach (Sliding Window)","text":"<p>Use a window <code>[left, right]</code> that expands to the right and contracts from the left when a duplicate is found. - Key Insight: We don't need to shrink strictly one by one. If <code>s[right]</code> is a duplicate of <code>s[index]</code>, we can jump <code>left</code> directly to <code>index + 1</code>. - Strategy:      1. Maintain <code>char_index_map</code> storing the last seen index of every char.     2. Expand <code>right</code> pointer from 0 to end.     3. If <code>s[right]</code> exists in map and is inside the current window (<code>map[char] &gt;= left</code>), update <code>left</code> to <code>map[char] + 1</code>.     4. Update <code>map[s[right]] = right</code>.     5. Track <code>max_length</code>.</p>"},{"location":"google/03_longest_substring/#trade-offs","title":"Trade-offs","text":"<ul> <li>Hash Map vs Set: Map allows \"jumping\" <code>left</code> pointer. A Set requires shrinking <code>left</code> one by one until duplicate is removed (amortized O(2N) vs strict O(N)).</li> </ul>"},{"location":"google/03_longest_substring/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass. Each character processed constant times. Space $O(M)$ $M$ is size of charset (e.g., 26 for letters, 128 for ASCII)."},{"location":"google/03_longest_substring/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n    classDef warning fill:#f59e0b,stroke:#fbbf24,stroke-width:2px,color:#0f172a\n\n    Init[\"Window: 'a', Left: 0, Right: 0\"] --&gt; Step1[\"Right moves to 'b'\"]\n    Step1 --&gt; Check{\"'b' seen?\"}\n    Check -- No --&gt; Map1[\"Map['b'] = 1 &lt;br/&gt; MaxLen = 2\"]\n    class Check primary\n\n    Map1 --&gt; Step2[\"Right moves to 'a' (duplicate)\"]\n    Step2 --&gt; Check2{\"'a' seen inside window?\"}\n    class Step2 warning\n\n    Check2 -- Yes --&gt; Jump[\"Move Left to Map['a'] + 1 = 1\"]\n    Jump --&gt; Update[\"Window becomes 'bca'\"]\n    class Jump success</code></pre>"},{"location":"google/03_longest_substring/#solution","title":"Solution","text":"<pre><code>def length_of_longest_substring(self, s: str) -&gt; int:\n    char_index_map = {}\n    max_length = 0\n    left = 0\n\n    for right, char in enumerate(s):\n        if char in char_index_map and char_index_map[char] &gt;= left:\n            left = char_index_map[char] + 1\n\n        char_index_map[char] = right\n        max_length = max(max_length, right - left + 1)\n\n    return max_length\n</code></pre>"},{"location":"google/04_kth_largest_element/","title":"Kth Largest Element in an Array \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Divide and Conquer</code>, <code>Sorting</code>, <code>Heap</code>, <code>QuickSelect</code></p>"},{"location":"google/04_kth_largest_element/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Heap (Priority Queue) \ud83d\udfe1 Medium Critical Efficiently tracks top K elements Sorting \ud83d\udfe2 Easy High Simple but less efficient (O(N log N)) solution"},{"location":"google/04_kth_largest_element/#the-challenge","title":"The Challenge","text":"<p>Given an integer array <code>nums</code> and an integer <code>k</code>, return the $k^{th}$ largest element in the array.</p> <p>Note that it is the $k^{th}$ largest element in the sorted order, not the $k^{th}$ distinct element.</p> <p>Constraints: - $1 \\leq k \\leq nums.length \\leq 10^5$ - $-10^4 \\leq nums[i] \\leq 10^4$</p> <p>Example: <pre><code>Input: nums = [3,2,1,5,6,4], k = 2\nOutput: 5\n</code></pre></p>"},{"location":"google/04_kth_largest_element/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/04_kth_largest_element/#naive-approach-sorting","title":"Naive Approach (Sorting)","text":"<p>Sort the entire array descending and pick index <code>k-1</code>. - Complexity: $O(N \\log N)$ time, $O(1)$ space (if in-place sort) or $O(N)$ (if Timsort/MergeSort). - Verdict: Acceptable, but we can do better if $N$ is huge and $K$ is small.</p>"},{"location":"google/04_kth_largest_element/#optimal-approach-min-heap","title":"Optimal Approach (Min-Heap)","text":"<p>Maintain a \"Top K Candidates\" club. - Concept: A Min-Heap of size <code>k</code> holds the $k$ largest elements seen so far. - Why Min-Heap? The root is the smallest of the big guys. If a new number is bigger than the root, it deserves to be in the club, so we evict the root (smallest giant) and add the new number. - Result: After processing all numbers, the root of the heap is the $k^{th}$ largest (the smallest of the top $k$).</p>"},{"location":"google/04_kth_largest_element/#alternative-quickselect","title":"Alternative (QuickSelect)","text":"<ul> <li>Concept: Partition array like QuickSort.</li> <li>Complexity: Avg $O(N)$, Worst $O(N^2)$.</li> <li>Verdict: Better average time, but Min-Heap is deterministic $O(N \\log K)$ and easier to implement safely without randomization.</li> </ul>"},{"location":"google/04_kth_largest_element/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\log K)$ We insert $N$ elements into a heap of max size $K$. Space $O(K)$ Heap stores $K$ elements."},{"location":"google/04_kth_largest_element/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Example: <code>[3, 2, 1, 5, 6, 4]</code>, <code>k = 2</code> (Find 2nd largest).</p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"Heap: []\"] --&gt; Add3[\"Add 3 -&gt; Heap: [3]\"]\n    Add3 --&gt; Add2[\"Add 2 -&gt; Heap: [2, 3]\"]\n    Add2 --&gt; Add1[\"Add 1 -&gt; Heap: [1, 2, 3] &lt;br/&gt; Size &gt; k! Pop 1 -&gt; [2, 3]\"]\n\n    Add1 --&gt; Add5[\"Add 5 -&gt; Heap: [2, 3, 5] &lt;br/&gt; Size &gt; k! Pop 2 -&gt; [3, 5]\"]\n    Add5 --&gt; Add6[\"Add 6 -&gt; Heap: [3, 5, 6] &lt;br/&gt; Size &gt; k! Pop 3 -&gt; [5, 6]\"]\n\n    Add6 --&gt; Add4[\"Add 4 -&gt; Heap: [4, 5, 6] &lt;br/&gt; Size &gt; k! Pop 4 -&gt; [5, 6]\"]\n    Add4 --&gt; Result[\"Result: Heap[0] = 5\"]\n    class Result success</code></pre>"},{"location":"google/04_kth_largest_element/#solution","title":"Solution","text":"<pre><code>def find_kth_largest(self, nums: list[int], k: int) -&gt; int:\n    heap = []\n    for num in nums:\n        heapq.heappush(heap, num)\n        if len(heap) &gt; k:\n            heapq.heappop(heap)\n    return heap[0]\n</code></pre>"},{"location":"google/05_merge_intervals/","title":"Merge Intervals \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Sorting</code></p>"},{"location":"google/05_merge_intervals/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Sorting \ud83d\udfe2 Easy Critical Sorting by start time enables single-pass merge Array Iteration \ud83d\udfe2 Easy High Processing intervals sequentially"},{"location":"google/05_merge_intervals/#the-challenge","title":"The Challenge","text":"<p>Given an array of <code>intervals</code> where <code>intervals[i] = [start_i, end_i]</code>, merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.</p> <p>Constraints: - $1 \\leq intervals.length \\leq 10^4$ - $intervals[i].length == 2$ - $0 \\leq start_i \\leq end_i \\leq 10^4$</p> <p>Example: <pre><code>Input: intervals = [[1,3],[2,6],[8,10],[15,18]]\nOutput: [[1,6],[8,10],[15,18]]\nExplanation: Intervals [1,3] and [2,6] overlap, so they merge into [1,6].\n</code></pre></p>"},{"location":"google/05_merge_intervals/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/05_merge_intervals/#naive-approach","title":"Naive Approach","text":"<p>Check every interval against every other interval. - Complexity: $O(N^2)$. - Issues: Handling complex multi-way overlaps (e.g., <code>[1,4], [2,5], [3,6]</code>) is messy without sorting.</p>"},{"location":"google/05_merge_intervals/#optimal-approach-sorting","title":"Optimal Approach (Sorting)","text":"<p>Sort intervals by their start time. - Intuition: If we sort by start times, overlapping intervals will be adjacent in the sorted list. - Algorithm:     1. Sort <code>intervals</code> by <code>start</code> time.     2. Initialize <code>merged</code> list with the first interval.     3. Iterate through remaining intervals:         - If current interval <code>[c_start, c_end]</code> overlaps with last merged interval <code>[m_start, m_end]</code> (i.e., <code>c_start &lt;= m_end</code>):             - Merge them by updating <code>m_end = max(m_end, c_end)</code>.         - Else (no overlap):             - Add current interval to <code>merged</code>. - Why it works: Since we processed in order of start times, we know <code>c_start &gt;= m_start</code>. The only check needed is if <code>c_start</code> starts before <code>m_end</code> finishes.</p>"},{"location":"google/05_merge_intervals/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\log N)$ Dominated by sorting. The merge pass is $O(N)$. Space $O(N)$ Storing sorted/merged output. In-place sort reduces aux space to $O(\\log N)$ or $O(1)$."},{"location":"google/05_merge_intervals/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[[1,3], [2,6], [8,10]]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Start[\"Sort -&gt; [[1,3], [2,6], [8,10]]\"] --&gt; Step1[\"Merged = [[1,3]]\"]\n    Step1 --&gt; Check1[\"Next: [2,6] &lt;br/&gt; Overlaps [1,3]? (2 &lt;= 3) -&gt; Yes\"]\n\n    Check1 --&gt; Merge1[\"Update end: max(3, 6) = 6 &lt;br/&gt; Merged = [[1,6]]\"]\n    class Merge1 primary\n\n    Merge1 --&gt; Check2[\"Next: [8,10] &lt;br/&gt; Overlaps [1,6]? (8 &lt;= 6) -&gt; No\"]\n    Check2 --&gt; Add1[\"Append [8,10] &lt;br/&gt; Merged = [[1,6], [8,10]]\"]\n    class Add1 success</code></pre>"},{"location":"google/05_merge_intervals/#solution","title":"Solution","text":"<pre><code>def merge(self, intervals: list[list[int]]) -&gt; list[list[int]]:\n    if not intervals:\n        return []\n\n    intervals.sort(key=lambda x: x[0])\n    merged = []\n\n    for interval in intervals:\n        if not merged or merged[-1][1] &lt; interval[0]:\n            merged.append(interval)\n        else:\n            merged[-1][1] = max(merged[-1][1], interval[1])\n\n    return merged\n</code></pre>"},{"location":"google/06_search_in_rotated_sorted_array/","title":"Search in Rotated Sorted Array \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Binary Search</code></p>"},{"location":"google/06_search_in_rotated_sorted_array/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Binary Search \ud83d\udfe2 Easy Critical Core logic is modified binary search Array Indexing \ud83d\udfe2 Easy High Handling rotated indices"},{"location":"google/06_search_in_rotated_sorted_array/#the-challenge","title":"The Challenge","text":"<p>There is an integer array <code>nums</code> sorted in ascending order (with distinct values).</p> <p>Prior to being passed to your function, <code>nums</code> is rotated at an unknown pivot index <code>k</code> ($1 \\leq k &lt; nums.length$) such that the resulting array is <code>[nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>.</p> <p>Given the array <code>nums</code> and an integer <code>target</code>, return the index of <code>target</code> if it is in <code>nums</code>, or <code>-1</code> if it is not.</p> <p>You must write an algorithm with $O(\\log n)$ runtime complexity.</p> <p>Constraints: - $1 \\leq nums.length \\leq 5000$ - $-10^4 \\leq nums[i] \\leq 10^4$ - All values of <code>nums</code> are unique. - <code>nums</code> is an ascending array that is possibly rotated.</p> <p>Example: <pre><code>Input: nums = [4,5,6,7,0,1,2], target = 0\nOutput: 4\n</code></pre></p>"},{"location":"google/06_search_in_rotated_sorted_array/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/06_search_in_rotated_sorted_array/#naive-approach","title":"Naive Approach","text":"<p>Linear search through the list. - Complexity: $O(N)$. - Issues: Fails the $O(\\log N)$ requirement.</p>"},{"location":"google/06_search_in_rotated_sorted_array/#optimal-approach-modified-binary-search","title":"Optimal Approach (Modified Binary Search)","text":"<p>Even though the array is rotated, one half of the array (relative to the midpoint) will always be sorted. - Logic:     1. Calculate <code>mid</code>.     2. Check if <code>nums[left] &lt;= nums[mid]</code>.         - If True: Left side <code>[left, mid]</code> is sorted.             - Check if <code>target</code> is in range <code>[nums[left], nums[mid])</code>.             - If yes, search left (<code>right = mid - 1</code>).             - Else, search right (<code>left = mid + 1</code>).         - If False: Right side <code>[mid, right]</code> is sorted.             - Check if <code>target</code> is in range <code>(nums[mid], nums[right]]</code>.             - If yes, search right (<code>left = mid + 1</code>).             - Else, search left (<code>right = mid - 1</code>). - Key Insight: We use the sorted half to determine if the target could be there. If not, we eliminate that half.</p>"},{"location":"google/06_search_in_rotated_sorted_array/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(\\log N)$ Standard binary search halving the search space. Space $O(1)$ No extra storage needed."},{"location":"google/06_search_in_rotated_sorted_array/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[4, 5, 6, 7, 0, 1, 2]</code>, <code>Target = 0</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n    classDef warning fill:#f59e0b,stroke:#fbbf24,stroke-width:2px,color:#0f172a\n\n    Init[\"Left: 0, Right: 6, Mid: 3 (Val 7)\"] --&gt; Check{\"Target 0 == 7?\"}\n    Check -- No --&gt; Sorted{\"Is Left (4) &lt;= Mid (7)?\"}\n\n    Sorted -- Yes --&gt; Range{\"Target 0 inside [4, 7]?\"}\n    class Sorted primary\n\n    Range -- No --&gt; Update1[\"Target must be in right half &lt;br/&gt; Left = Mid + 1 = 4\"]\n    class Range warning\n\n    Update1 --&gt; Step2[\"Left: 4, Right: 6, Mid: 5 (Val 1)\"]\n    Step2 --&gt; Check2{\"Target 0 == 1?\"}\n    Check2 -- No --&gt; Sorted2{\"Is Left (0) &lt;= Mid (1)?\"}\n\n    Sorted2 -- Yes --&gt; Range2{\"Target 0 inside [0, 1]?\"}\n    Range2 -- Yes --&gt; Update2[\"Right = Mid - 1 = 4\"]\n\n    Update2 --&gt; Step3[\"Left: 4, Right: 4, Mid: 4 (Val 0)\"]\n    Step3 --&gt; Found[\"Target Found at 4\"]\n    class Found success</code></pre>"},{"location":"google/06_search_in_rotated_sorted_array/#solution","title":"Solution","text":"<pre><code>def search(self, nums: list[int], target: int) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    while left &lt;= right:\n        mid = (left + right) // 2\n\n        if nums[mid] == target:\n            return mid\n\n        # If left side is sorted\n        if nums[left] &lt;= nums[mid]:\n            if nums[left] &lt;= target &lt; nums[mid]:\n                right = mid - 1\n            else:\n                left = mid + 1\n        # If right side is sorted\n        else:\n            if nums[mid] &lt; target &lt;= nums[right]:\n                left = mid + 1\n            else:\n                right = mid - 1\n\n    return -1\n</code></pre>"},{"location":"google/07_valid_parentheses/","title":"Valid Parentheses \ud83d\udfe2 Easy","text":"<p>Tags: <code>Stack</code>, <code>String</code></p>"},{"location":"google/07_valid_parentheses/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Stack Operations \ud83d\udfe2 Easy Critical Last-In-First-Out (LIFO) property is exact match for nested structures String Iteration \ud83d\udfe2 Easy High Processing chars one by one"},{"location":"google/07_valid_parentheses/#the-challenge","title":"The Challenge","text":"<p>Given a string <code>s</code> containing just the characters <code>'('</code>, <code>')'</code>, <code>'{'</code>, <code>'}'</code>, <code>'['</code> and <code>']'</code>, determine if the input string is valid.</p> <p>An input string is valid if: 1. Open brackets must be closed by the same type of brackets. 2. Open brackets must be closed in the correct order. 3. Every close bracket has a corresponding open bracket of the same type.</p> <p>Constraints: - $1 \\leq s.length \\leq 10^4$ - <code>s</code> consists of parentheses only <code>()[]{}</code>.</p> <p>Example: <pre><code>Input: s = \"()[]{}\"\nOutput: true\n\nInput: s = \"(]\"\nOutput: false\n</code></pre></p>"},{"location":"google/07_valid_parentheses/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/07_valid_parentheses/#naive-approach","title":"Naive Approach","text":"<p>Repeatedly replace innermost valid pairs <code>()</code> <code>[]</code> <code>{}</code> with empty strings until string is empty or no changes occur. - Complexity: $O(N^2)$ due to repeated string modification and scanning. - Issues: String manipulation is expensive.</p>"},{"location":"google/07_valid_parentheses/#optimal-approach-stack","title":"Optimal Approach (Stack)","text":"<p>Use a Stack to keep track of opening brackets. - Why Stack?: The last opening bracket must be the first one closed (LIFO). - Algorithm:     1. Initialize empty <code>stack</code>.     2. Map closing brackets to opening ones: <code>} -&gt; {</code>.     3. Iterate through <code>s</code>:         - If <code>char</code> is an opening bracket: Push to <code>stack</code>.         - If <code>char</code> is a closing bracket:             - Check if <code>stack</code> is empty (invalid).             - Pop from <code>stack</code>. If popped char doesn't match mapping, return <code>False</code>.     4. After loop, return <code>True</code> if <code>stack</code> is empty (all opened were closed), else <code>False</code>.</p>"},{"location":"google/07_valid_parentheses/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass through the string. Push/Pop are $O(1)$. Space $O(N)$ In worst case (<code>((((</code>), stack stores all chars."},{"location":"google/07_valid_parentheses/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>([{}])</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n    classDef warning fill:#f59e0b,stroke:#fbbf24,stroke-width:2px,color:#0f172a\n\n    Start[\"Stack: []\"] --&gt; Push1[\"Push '(' &lt;br/&gt; Stack: ['(']\"]\n    Push1 --&gt; Push2[\"Push '[' &lt;br/&gt; Stack: ['(', '[']\"]\n    Push2 --&gt; Push3[\"Push '{' &lt;br/&gt; Stack: ['(', '[', '{']\"]\n\n    Push3 --&gt; Pop1[\"Char '}' matches '{'? Yes. &lt;br/&gt; Pop '{' -&gt; Stack: ['(', '[']\"]\n    class Pop1 primary\n\n    Pop1 --&gt; Pop2[\"Char ']' matches '['? Yes. &lt;br/&gt; Pop '[' -&gt; Stack: ['(']\"]\n    Pop2 --&gt; Pop3[\"Char ')' matches '('? Yes. &lt;br/&gt; Pop '(' -&gt; Stack: []\"]\n\n    Pop3 --&gt; End[\"String empty. Stack empty? Yes. &lt;br/&gt; VALID\"]\n    class End success</code></pre>"},{"location":"google/07_valid_parentheses/#solution","title":"Solution","text":"<pre><code>def is_valid_parentheses(self, s: str) -&gt; bool:\n    stack = []\n    mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n    for char in s:\n        if char in mapping:\n            top_element = stack.pop() if stack else '#'\n            if mapping[char] != top_element:\n                return False\n        else:\n            stack.append(char)\n\n    return not stack\n</code></pre>"},{"location":"google/08_word_ladder/","title":"Word Ladder \ud83d\udd34 Hard","text":"<p>Tags: <code>Breadth-First Search</code>, <code>Strng</code>, <code>Hash Table</code></p>"},{"location":"google/08_word_ladder/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Breadth-First Search \ud83d\udfe1 Medium Critical Shortest path in unweighted graph = BFS Hash Set \ud83d\udfe2 Easy High O(1) lookups for word existence"},{"location":"google/08_word_ladder/#the-challenge","title":"The Challenge","text":"<p>A transformation sequence from <code>beginWord</code> to <code>endWord</code> is a sequence of words <code>beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk</code> such that: 1. Every adjacent pair of words differs by a single letter. 2. Every <code>si</code> for <code>1 &lt;= i &lt;= k</code> is in <code>wordList</code>. Note that <code>beginWord</code> does not need to be in <code>wordList</code>. 3. <code>sk == endWord</code>.</p> <p>Given <code>beginWord</code>, <code>endWord</code>, and a dictionary <code>wordList</code>, return the number of words in the shortest transformation sequence from <code>beginWord</code> to <code>endWord</code>, or <code>0</code> if no such sequence exists.</p> <p>Constraints: - $1 \\leq beginWord.length \\leq 10$ - $1 \\leq wordList.length \\leq 5000$ - All words typically lowercase English letters.</p> <p>Example: <pre><code>Input: beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\nOutput: 5\nExplanation: \"hit\" -&gt; \"hot\" -&gt; \"dot\" -&gt; \"dog\" -&gt; \"cog\"\n</code></pre></p>"},{"location":"google/08_word_ladder/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/08_word_ladder/#naive-approach-dfs","title":"Naive Approach (DFS)","text":"<p>Try every path recursively. - Issues: Finds a path, not necessarily the shortest. Can get stuck in cycles (needs visited set). Extremely slow for shortest path.</p>"},{"location":"google/08_word_ladder/#optimal-approach-bfs","title":"Optimal Approach (BFS)","text":"<p>Treat words as nodes in a graph. An edge exists if words differ by 1 char. Find shortest path from Start to End. - Strategy:     1. Push <code>(beginWord, 1)</code> to Queue.     2. Maintain <code>visited</code> set to avoid loops.     3. While Queue not empty:         - Pop <code>current_word</code>.         - Generate all possible next words (change 1 char A-Z).         - If neighbor is in <code>wordList</code> and not visited:             - If neighbor == <code>endWord</code>, return <code>level + 1</code>.             - Add to Queue, Mark visited. - Optimization: Instead of checking every word in <code>wordList</code> (O(N * M)), generate all 26*M variations and check set existence (O(26 * M)). Since M is small (&lt;= 10), this is faster.</p>"},{"location":"google/08_word_ladder/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(M^2 \\times N)$ $M$ = word len, $N$ = list size. We process each word, and for each char, gen 26 vars. String creation is $O(M)$. Space $O(M \\times N)$ To store <code>visited</code> and Queue."},{"location":"google/08_word_ladder/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Start: <code>hit</code>. Target: <code>cog</code>.</p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    L1[\"Level 1: hit\"] --&gt; L2[\"Level 2: hot\"]\n    class L1 primary\n\n    L2 --&gt; L3A[\"Level 3: dot\"]\n    L2 --&gt; L3B[\"Level 3: lot\"]\n\n    L3A --&gt; L4A[\"Level 4: dog\"]\n    L3B --&gt; L4B[\"Level 4: log\"]\n\n    L4A --&gt; L5[\"Level 5: cog (Target!)\"]\n    L4B --&gt; L5\n    class L5 success</code></pre>"},{"location":"google/08_word_ladder/#solution","title":"Solution","text":"<pre><code>def ladder_length(self, begin_word: str, end_word: str, word_list: list[str]) -&gt; int:\n    word_set = set(word_list)\n    if end_word not in word_set:\n        return 0\n\n    queue = deque([(begin_word, 1)])\n    visited = set([begin_word])\n\n    while queue:\n        current_word, level = queue.popleft()\n\n        if current_word == end_word:\n            return level\n\n        for i in range(len(current_word)):\n            original_char = current_word[i]\n            for c in range(ord('a'), ord('z') + 1):\n                char = chr(c)\n                if char == original_char: continue\n\n                new_word = current_word[:i] + char + current_word[i+1:]\n                if new_word in word_set and new_word not in visited:\n                    visited.add(new_word)\n                    queue.append((new_word, level + 1))\n\n    return 0\n</code></pre>"},{"location":"google/09_container_most_water/","title":"Container With Most Water \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Two Pointers</code>, <code>Greedy</code></p>"},{"location":"google/09_container_most_water/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Two Pointers \ud83d\udfe2 Easy Critical Moving from both ends Greedy Strategy \ud83d\udfe1 Medium High Making local optimal choice"},{"location":"google/09_container_most_water/#the-challenge","title":"The Challenge","text":"<p>You are given an integer array <code>height</code> of length <code>n</code>. There are <code>n</code> vertical lines drawn such that the two endpoints of the $i^{th}$ line are <code>(i, 0)</code> and <code>(i, height[i])</code>.</p> <p>Find two lines that together with the x-axis form a container, such that the container contains the most water.</p> <p>Return the maximum amount of water a container can store.</p> <p>Constraints: - $n == height.length$ - $2 \\leq n \\leq 10^5$ - $0 \\leq height[i] \\leq 10^4$</p> <p>Example: <pre><code>Input: height = [1,8,6,2,5,4,8,3,7]\nOutput: 49\nExplanation: The max area is between index 1 (height 8) and index 8 (height 7). \nWidth = 8 - 1 = 7. Height = min(8, 7) = 7. Area = 7 * 7 = 49.\n</code></pre></p>"},{"location":"google/09_container_most_water/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/09_container_most_water/#naive-approach","title":"Naive Approach","text":"<p>Check every pair of lines. - Complexity: $O(N^2)$. - Fail: TLE for $N=10^5$.</p>"},{"location":"google/09_container_most_water/#optimal-approach-two-pointers","title":"Optimal Approach (Two Pointers)","text":"<p>Start with the widest possible container (indices <code>0</code> and <code>N-1</code>) and shrink inwards. - Key Insight: The area is determined by the shorter wall.      - <code>Area = (right - left) * min(height[left], height[right])</code>. - Strategy:     1. Initialize <code>left=0</code>, <code>right=N-1</code>.     2. Calc area, update max.     3. To potentially find a bigger area, we must find a higher wall.      4. Greedy Choice: Move the pointer pointing to the shorter wall.          - Why? Moving the taller wall can ONLY reduce area (width decreases, height is still limited by the short wall).         - Moving the shorter wall gives a chance to find a taller one.     5. Repeat until pointers meet.</p>"},{"location":"google/09_container_most_water/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass from ends to center. Space $O(1)$ Constant extra space."},{"location":"google/09_container_most_water/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[1, 8, 6, 2, 5, 4, 8, 3, 7]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"L:0 (1), R:8 (7)\"] --&gt; Calc1[\"Area: 8*1 = 8 &lt;br/&gt; Move L (1 &lt; 7)\"]\n    Calc1 --&gt; Step2[\"L:1 (8), R:8 (7)\"]\n\n    Step2 --&gt; Calc2[\"Area: 7*7 = 49 (Max) &lt;br/&gt; Move R (7 &lt; 8)\"]\n    Calc2 --&gt; Step3[\"L:1 (8), R:7 (3)\"]\n    class Calc2 success\n\n    Step3 --&gt; Calc3[\"Area: 6*3 = 18 &lt;br/&gt; Move R (3 &lt; 8)\"]\n    Calc3 --&gt; Step4[\"...\"]</code></pre>"},{"location":"google/09_container_most_water/#solution","title":"Solution","text":"<pre><code>def max_area(self, height: list[int]) -&gt; int:\n    left, right = 0, len(height) - 1\n    max_water = 0\n\n    while left &lt; right:\n        width = right - left\n        current_height = min(height[left], height[right])\n        max_water = max(max_water, width * current_height)\n\n        if height[left] &lt; height[right]:\n            left += 1\n        else:\n            right -= 1\n\n    return max_water\n</code></pre>"},{"location":"google/10_subset_sum_ii/","title":"Subset Sum II \ud83d\udfe1 Medium","text":"<p>Tags: <code>Backtracking</code>, <code>Array</code>, <code>Bit Manipulation</code></p>"},{"location":"google/10_subset_sum_ii/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Backtracking \ud83d\udfe1 Medium Critical Generating power set Sorting \ud83d\udfe2 Easy High Handling duplicates requires sorted input"},{"location":"google/10_subset_sum_ii/#the-challenge","title":"The Challenge","text":"<p>Given an integer array <code>nums</code> that may contain duplicates, return all possible subsets (the power set).</p> <p>The solution set must not contain duplicate subsets. Return the solution in any order.</p> <p>Constraints: - $1 \\leq nums.length \\leq 10$ - $-10 \\leq nums[i] \\leq 10$</p> <p>Example: <pre><code>Input: nums = [1,2,2]\nOutput: [[],[1],[1,2],[1,2,2],[2],[2,2]]\n</code></pre></p>"},{"location":"google/10_subset_sum_ii/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/10_subset_sum_ii/#naive-approach","title":"Naive Approach","text":"<p>Generate all $2^N$ subsets and use a <code>Set</code> of tuples to filter duplicates. - Issues: Requires converting lists to tuples for hashing.</p>"},{"location":"google/10_subset_sum_ii/#optimal-approach-backtracking-with-pruning","title":"Optimal Approach (Backtracking with Pruning)","text":"<p>Sort the array first to handle duplicates efficiently during generation. - Logic:     - Sort <code>nums</code>.     - Function <code>backtrack(start, current_subset)</code>:         - Add <code>current_subset</code> to results.         - Loop <code>i</code> from <code>start</code> to <code>len(nums)</code>:             - Skip Duplicates: If <code>i &gt; start</code> and <code>nums[i] == nums[i-1]</code>, continue. This prevents processing the same number at the same \"level\" of the tree twice.             - Include <code>nums[i]</code>.             - Recurse <code>backtrack(i + 1, ...)</code>.             - Exclude (pop) <code>nums[i]</code>.</p>"},{"location":"google/10_subset_sum_ii/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\times 2^N)$ $2^N$ subsets. Copying each takes $O(N)$. Space $O(N)$ Recursion stack depth is $N$."},{"location":"google/10_subset_sum_ii/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[1, 2, 2]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Root[\"[]\"] --&gt; Add1[\"[1]\"]\n    Root --&gt; Add2[\"[2]\"]\n    Root --&gt; Skip[\"Skip 2nd '2'\"]\n\n    Add1 --&gt; Add12[\"[1, 2]\"]\n    Add12 --&gt; Add122[\"[1, 2, 2]\"]\n    class Add122 success\n\n    Add2 --&gt; Add22[\"[2, 2]\"]</code></pre>"},{"location":"google/10_subset_sum_ii/#solution","title":"Solution","text":"<pre><code>def subsets_with_dup(self, nums: list[int]) -&gt; list[list[int]]:\n    results = []\n    nums.sort()\n\n    def backtrack(start_index: int, current_subset: list[int]):\n        results.append(list(current_subset))\n\n        for i in range(start_index, len(nums)):\n            if i &gt; start_index and nums[i] == nums[i - 1]:\n                continue\n\n            current_subset.append(nums[i])\n            backtrack(i + 1, current_subset)\n            current_subset.pop()\n\n    backtrack(0, [])\n    return results\n</code></pre>"},{"location":"google/11_find_median_data_stream/","title":"Find Median from Data Stream \ud83d\udd34 Hard","text":"<p>Tags: <code>Heap</code>, <code>Design</code>, <code>Data Stream</code></p>"},{"location":"google/11_find_median_data_stream/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Priority Queue (Heap) \ud83d\udfe1 Medium Critical Maintaining sorted halves efficienty Object-Oriented Design \ud83d\udfe2 Easy High Class structure"},{"location":"google/11_find_median_data_stream/#the-challenge","title":"The Challenge","text":"<p>The median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value, and the median is the mean of the two middle values.</p> <p>Implement the <code>MedianFinder</code> class: - <code>MedianFinder()</code> initializes the <code>MedianFinder</code> object. - <code>void addNum(int num)</code> adds the integer <code>num</code> from the data stream to the data structure. - <code>double findMedian()</code> returns the median of all elements so far.</p> <p>Constraints: - $-10^5 \\leq num \\leq 10^5$ - There will be at least one element in the data structure before calling <code>findMedian</code>. - At most $5 \\times 10^4$ calls will be made to <code>addNum</code> and <code>findMedian</code>.</p> <p>Example: <pre><code>mf = MedianFinder()\nmf.addNum(1)    # arr = [1]\nmf.addNum(2)    # arr = [1, 2]\nmf.findMedian() # return 1.5 ((1 + 2) / 2)\nmf.addNum(3)    # arr = [1, 2, 3]\nmf.findMedian() # return 2.0\n</code></pre></p>"},{"location":"google/11_find_median_data_stream/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/11_find_median_data_stream/#naive-approach-sorting","title":"Naive Approach (Sorting)","text":"<p>Store list and sort it every time <code>findMedian</code> is called. - Complexity: $O(N \\log N)$ per find. With $N$ calls, total $O(N^2 \\log N)$. - Improvements: Insertion Sort ($O(N)$ insertion).</p>"},{"location":"google/11_find_median_data_stream/#optimal-approach-two-heaps","title":"Optimal Approach (Two Heaps)","text":"<p>Maintain two halves of the data: 1. Small Half: Stores the smaller numbers. We need the largest of these. -&gt; Max-Heap. 2. Large Half: Stores the larger numbers. We need the smallest of these. -&gt; Min-Heap.</p> <ul> <li> <p>Invariants:</p> <ol> <li>Size balance: <code>len(small) == len(large)</code> (even total) or <code>len(small) == len(large) + 1</code> (odd total).</li> <li>Order property: <code>max(small) &lt;= min(large)</code>.</li> </ol> </li> <li> <p>Add Logic:</p> <ul> <li>Push to <code>small</code> (invert sign for min-heap implementation).</li> <li>Pop from <code>small</code>, push to <code>large</code> (ensures order property).</li> <li>If <code>large</code> is bigger than <code>small</code>, pop <code>large</code>, push <code>small</code>.</li> </ul> </li> <li> <p>Find Logic:</p> <ul> <li>If <code>len(small) &gt; len(large)</code>, median is <code>small.top</code>.</li> <li>Else, median is <code>(small.top + large.top) / 2</code>.</li> </ul> </li> </ul>"},{"location":"google/11_find_median_data_stream/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time (Add) $O(\\log N)$ Heap push/pop. Time (Find) $O(1)$ Top of heaps access. Space $O(N)$ Storing all elements."},{"location":"google/11_find_median_data_stream/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[1, 2, 3]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"Small: [], Large: []\"] --&gt; Add1[\"Add 1 -&gt; Small: [-1]\"]\n    Add1 --&gt; Check1[\"Balances OK. Median = 1\"]\n    class Check1 primary\n\n    Check1 --&gt; Add2[\"Add 2 -&gt; Small: [-2, -1] -&gt; Pop -2 -&gt; Large: [2]\"]\n    Add2 --&gt; Balance2[\"Len Equal. Median = (1 + 2)/2 = 1.5\"]\n\n    Balance2 --&gt; Add3[\"Add 3 -&gt; Small: [-1] ... Logic\"]\n    Add3 --&gt; Final[\"Small: [-1, -2] (Vals 1, 2), Large: [3] -&gt; Rebal?\"]\n\n    Final --&gt; Correct[\"Small: [-2, -1] (Vals 1, 2), Large: [3] -&gt; Pop Small(-1) -&gt; Large[1,3] -&gt; Pop Large(1) -&gt; Small\"]\n    Correct --&gt; Result[\"Small: [-2, -1], Large: [3]. Median = 2\"]\n    class Result success</code></pre>"},{"location":"google/11_find_median_data_stream/#solution","title":"Solution","text":"<pre><code>class MedianFinder:\n    def __init__(self):\n        self.small = []  # Max-heap (inverted)\n        self.large = []  # Min-heap\n\n    def add_num(self, num: int) -&gt; None:\n        heapq.heappush(self.small, -num)\n\n        # Ensure order\n        if self.small and self.large and (-self.small[0] &gt; self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # Ensure balance\n        if len(self.small) &gt; len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) &gt; len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def find_median(self) -&gt; float:\n        if len(self.small) &gt; len(self.large):\n            return float(-self.small[0])\n        return (-self.small[0] + self.large[0]) / 2.0\n</code></pre>"},{"location":"google/12_minimum_window_substring/","title":"Minimum Window Substring \ud83d\udd34 Hard","text":"<p>Tags: <code>Sliding Window</code>, <code>Hash Table</code>, <code>String</code></p>"},{"location":"google/12_minimum_window_substring/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Sliding Window \ud83d\udfe1 Medium Critical Variable size window contraction Hash Map (Frequency) \ud83d\udfe2 Easy High Tracking character counts"},{"location":"google/12_minimum_window_substring/#the-challenge","title":"The Challenge","text":"<p>Given two strings <code>s</code> and <code>t</code> of lengths <code>m</code> and <code>n</code> respectively, return the minimum window substring of <code>s</code> such that every character in <code>t</code> (including duplicates) is included in the window. If there is no such substring, return the empty string <code>\"\"</code>.</p> <p>The testcases will be generated such that the answer is unique.</p> <p>Constraints: - $m == s.length$ - $n == t.length$ - $1 \\leq m, n \\leq 10^5$ - <code>s</code> and <code>t</code> consist of uppercase and lowercase English letters.</p> <p>Example: <pre><code>Input: s = \"ADOBECODEBANC\", t = \"ABC\"\nOutput: \"BANC\"\nExplanation: The minimum window substring \"BANC\" includes 'A', 'B', and 'C'.\n</code></pre></p>"},{"location":"google/12_minimum_window_substring/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/12_minimum_window_substring/#naive-approach","title":"Naive Approach","text":"<p>Check all substrings of <code>s</code>. - Complexity: $O(N^3)$ or $O(N^2)$. - Fail: TLE.</p>"},{"location":"google/12_minimum_window_substring/#optimal-approach-sliding-window","title":"Optimal Approach (Sliding Window)","text":"<p>Expand <code>right</code> to satisfy <code>t</code>. Once valid, contract <code>left</code> to minimize. - Logic:     1. Count chars in <code>t</code> -&gt; <code>dict_t</code>.     2. <code>required = len(dict_t)</code>.     3. Expand <code>right</code>. Add <code>s[right]</code> to <code>window_counts</code>.     4. If conditions for a char met (<code>window[c] == t[c]</code>), <code>formed++</code>.     5. While <code>formed == required</code> (VALID WINDOW):         - Update <code>min_len</code>, <code>ans</code>.         - Remove <code>s[left]</code>. If count drops below required, <code>formed--</code>.         - <code>left++</code>.</p>"},{"location":"google/12_minimum_window_substring/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(S + T)$ Process each char in <code>s</code> at most twice (add/remove). Space $O(1)$ Hash map size limited by charset (128 chars)."},{"location":"google/12_minimum_window_substring/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>s=\"ADOBECODEBANC\", t=\"ABC\"</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"Window: []\"] --&gt; Expand[\"Expand Right -&gt; ... -&gt; ADOBEC\"]\n    Expand --&gt; Check[\"Includes A, B, C? Yes. &lt;br/&gt; Len: 6\"]\n    class Check primary\n\n    Check --&gt; Contract[\"Contract Left -&gt; DOBEC (Lost A, Invalid)\"]\n    Contract --&gt; Expand2[\"Expand Right -&gt; ... -&gt; ADOBECODEBANC\"]\n\n    Expand2 --&gt; Check2[\"Valid. Contract Left -&gt; ... -&gt; BANC\"]\n    Check2 --&gt; Final[\"Min Len: 4 (BANC)\"]\n    class Final success</code></pre>"},{"location":"google/12_minimum_window_substring/#solution","title":"Solution","text":"<pre><code>def min_window(self, s: str, t: str) -&gt; str:\n    if not t or not s: return \"\"\n    dict_t = {}\n    for char in t: dict_t[char] = dict_t.get(char, 0) + 1\n    required = len(dict_t)\n    l, r, formed = 0, 0, 0\n    window_counts = {}\n    ans = float(\"inf\"), None, None\n\n    while r &lt; len(s):\n        char = s[r]\n        window_counts[char] = window_counts.get(char, 0) + 1\n        if char in dict_t and window_counts[char] == dict_t[char]:\n            formed += 1\n\n        while l &lt;= r and formed == required:\n            char = s[l]\n            if r - l + 1 &lt; ans[0]:\n                ans = (r - l + 1, l, r)\n            window_counts[char] -= 1\n            if char in dict_t and window_counts[char] &lt; dict_t[char]:\n                formed -= 1\n            l += 1    \n        r += 1\n    return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]\n</code></pre>"},{"location":"google/13_reverse_nodes_k_group/","title":"Reverse Nodes in k-Group \ud83d\udd34 Hard","text":"<p>Tags: <code>Linked List</code>, <code>Recursion</code></p>"},{"location":"google/13_reverse_nodes_k_group/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Linked List Reversal \ud83d\udfe2 Easy Critical Standard reversal logic needed Recursion \ud83d\udfe1 Medium High Simplifies processing subsequent groups"},{"location":"google/13_reverse_nodes_k_group/#the-challenge","title":"The Challenge","text":"<p>Given the head of a linked list, reverse the nodes of the list <code>k</code> at a time, and return the modified list.</p> <p><code>k</code> is a positive integer and is less than or equal to the length of the linked list. If the number of nodes is not a multiple of <code>k</code> then left-out nodes, in the end, should remain as it is.</p> <p>You may not alter the values in the list's nodes, only nodes themselves may be changed.</p> <p>Constraints: - Number of nodes in list is in range $[0, 5000]$. - $0 \\leq Node.val \\leq 1000$ - $1 \\leq k \\leq length$</p> <p>Example: <pre><code>Input: head = [1,2,3,4,5], k = 2\nOutput: [2,1,4,3,5]\n</code></pre></p>"},{"location":"google/13_reverse_nodes_k_group/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/13_reverse_nodes_k_group/#naive-approach","title":"Naive Approach","text":"<p>Store in array, reverse chunks, rebuild list. - Space: $O(N)$ (not allowed, usually O(1) expected).</p>"},{"location":"google/13_reverse_nodes_k_group/#optimal-approach-iterativerecursive","title":"Optimal Approach (Iterative/Recursive)","text":"<p>Process <code>k</code> nodes at a time. - Logic:     1. Check if <code>k</code> nodes exist from current head. If not, return head (don't reverse).     2. Reverse the first <code>k</code> nodes.     3. The original head is now the tail of this group.     4. Recursively call <code>reverse_k_group</code> on the next segment.     5. Link the new tail (original head) to the result of recursion.     6. Return the new head (original kth node).</p>"},{"location":"google/13_reverse_nodes_k_group/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Each node touched twice (check exist, then reverse). Space $O(1)$ Iterative. Recursive uses $O(N/K)$ stack."},{"location":"google/13_reverse_nodes_k_group/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>, <code>k=2</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Start[\"H:1, K:2. Check 2 nodes? Yes.\"] --&gt; Rev1[\"Reverse 1-2. New H:2. Tail:1.\"]\n    Rev1 --&gt; Recurse[\"Call k-group(3, 2)\"]\n    class Rev1 primary\n\n    Recurse --&gt; Rev2[\"Reverse 3-4. New H:4. Tail:3.\"]\n    Rev2 --&gt; Recurse2[\"Call k-group(5, 2)\"]\n\n    Recurse2 --&gt; Base[\"Only 1 node (5). Return 5.\"]\n    Base --&gt; Link2[\"Link Tail 3 -&gt; 5. Return 4.\"]\n    Link2 --&gt; Link1[\"Link Tail 1 -&gt; 4. Return 2.\"]\n\n    Link1 --&gt; Result[\"2-&gt;1-&gt;4-&gt;3-&gt;5\"]\n    class Result success</code></pre>"},{"location":"google/13_reverse_nodes_k_group/#solution","title":"Solution","text":"<pre><code>def reverse_k_group(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n    if not head or k == 1:\n        return head\n\n    curr = head\n    count = 0\n    while curr and count &lt; k:\n        curr = curr.next\n        count += 1\n\n    if count &lt; k:\n        return head\n\n    prev = None\n    curr = head\n    for _ in range(k):\n        next_node = curr.next\n        curr.next = prev\n        prev = curr\n        curr = next_node\n\n    if head:\n        head.next = self.reverse_k_group(curr, k)\n\n    return prev\n</code></pre>"},{"location":"google/14_find_min_rotated_sorted/","title":"Find Minimum in Rotated Sorted Array \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Binary Search</code></p>"},{"location":"google/14_find_min_rotated_sorted/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Binary Search \ud83d\udfe2 Easy Critical Identifying the inflection point"},{"location":"google/14_find_min_rotated_sorted/#the-challenge","title":"The Challenge","text":"<p>Suppose an array of length <code>n</code> sorted in ascending order is rotated between <code>1</code> and <code>n</code> times. For example, the array <code>nums = [0,1,2,4,5,6,7]</code> might become: - <code>[4,5,6,7,0,1,2]</code> if it was rotated 4 times. - <code>[0,1,2,4,5,6,7]</code> if it was rotated 7 times.</p> <p>Notice that rotating an array <code>[a[0], a[1], a[2], ..., a[n-1]]</code> 1 time results in the array <code>[a[n-1], a[0], a[1], a[2], ..., a[n-2]]</code>.</p> <p>Given the sorted rotated array <code>nums</code> of unique elements, return the minimum element of this array.</p> <p>You must write an algorithm that runs in $O(\\log n)$ time.</p> <p>Constraints: - $n == nums.length$ - $1 \\leq n \\leq 5000$ - $-5000 \\leq nums[i] \\leq 5000$ - All integers in <code>nums</code> are unique.</p> <p>Example: <pre><code>Input: nums = [3,4,5,1,2]\nOutput: 1\n</code></pre></p>"},{"location":"google/14_find_min_rotated_sorted/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"google/14_find_min_rotated_sorted/#naive-approach","title":"Naive Approach","text":"<p>Linear scan. - Complexity: $O(N)$. - Fail: Does not meet $O(\\log N)$ constraint.</p>"},{"location":"google/14_find_min_rotated_sorted/#optimal-approach-binary-search","title":"Optimal Approach (Binary Search)","text":"<p>Find the point where order breaks ($nums[i] &gt; nums[i+1]$). - Logic:     - <code>left</code>, <code>right</code>.     - Loop while <code>left &lt; right</code>:         - <code>mid = (left + right) // 2</code>.         - If <code>nums[mid] &gt; nums[right]</code>:              - Mid is part of the left ascending chunk (large values).             - Minimum must be to the right (pivot is in right half).             - <code>left = mid + 1</code>.         - Else (<code>nums[mid] &lt;= nums[right]</code>):             - Mid is part of the right ascending chunk (small values) OR array is not rotated.             - Minimum is at <code>mid</code> or to the left.             - <code>right = mid</code> (NOT <code>mid - 1</code> because mid could be the min).     - Return <code>nums[left]</code>.</p>"},{"location":"google/14_find_min_rotated_sorted/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(\\log N)$ Standard binary search. Space $O(1)$ No extra space."},{"location":"google/14_find_min_rotated_sorted/#visual-walkthrough","title":"Visual Walkthrough","text":"<p>Input: <code>[3, 4, 5, 1, 2]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Init[\"L:0 (3), R:4 (2), Mid:2 (5)\"] --&gt; Check[\"Mid(5) &gt; R(2)? Yes.\"]\n    class Check primary\n\n    Check --&gt; Update1[\"Min is right of Mid. &lt;br/&gt; Left = Mid + 1 = 3\"]\n    Update1 --&gt; Step2[\"L:3 (1), R:4 (2), Mid:3 (1)\"]\n\n    Step2 --&gt; Check2[\"Mid(1) &gt; R(2)? No.\"]\n    Check2 --&gt; Update2[\"Right = Mid = 3\"]\n\n    Update2 --&gt; LoopEnd[\"L:3, R:3. Loop Ends.\"]\n    LoopEnd --&gt; Result[\"Return nums[3] = 1\"]\n    class Result success</code></pre>"},{"location":"google/14_find_min_rotated_sorted/#solution","title":"Solution","text":"<pre><code>def find_min(self, nums: list[int]) -&gt; int:\n    left, right = 0, len(nums) - 1\n\n    if nums[left] &lt;= nums[right]:\n        return nums[left]\n\n    while left &lt; right:\n        mid = (left + right) // 2\n\n        if nums[mid] &gt; nums[right]:\n            left = mid + 1\n        else:\n            right = mid\n\n    return nums[left]\n</code></pre>"},{"location":"microsoft/","title":"Microsoft DSA Problems","text":"<p>This section contains solutions for common DSA problems asked in Microsoft interviews.</p> <p>Use the sidebar or the Problem Mapping to find specific solutions.</p>"},{"location":"microsoft/01_evaluate_rpn/","title":"Evaluate Reverse Polish Notation \ud83d\udfe1 Medium","text":"<p>Tags: <code>Stack</code>, <code>Math</code></p>"},{"location":"microsoft/01_evaluate_rpn/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Stack Operations \ud83d\udfe2 Easy Critical Operand storage"},{"location":"microsoft/01_evaluate_rpn/#the-challenge","title":"The Challenge","text":"<p>Evaluate the value of an arithmetic expression in Reverse Polish Notation. Valid operators are <code>+</code>, <code>-</code>, <code>*</code>, and <code>/</code>. Each operand may be an integer or another expression. Division between two integers should truncate toward zero.</p> <p>Constraints: - $1 \\leq tokens.length \\leq 10^4$ - tokens[i] is an operator or integer.</p> <p>Example: <pre><code>Input: tokens = [\"2\",\"1\",\"+\",\"3\",\"*\"]\nOutput: 9\nExplanation: ((2 + 1) * 3) = 9\n</code></pre></p>"},{"location":"microsoft/01_evaluate_rpn/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/01_evaluate_rpn/#optimal-approach-stack","title":"Optimal Approach (Stack)","text":"<p>Standard RPN evaluation. - Logic:     - If number: Push to stack.     - If operator: Pop two numbers (<code>b</code> then <code>a</code>), Apply op <code>a &lt;op&gt; b</code>, Push result. - Note: For division <code>/</code>, Python's <code>//</code> works like floor. Use <code>int(a / b)</code> for truncate toward zero (e.g., <code>6 / -132</code> -&gt; <code>0</code>).</p>"},{"location":"microsoft/01_evaluate_rpn/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Compilers (AST code generation), Postscript (PDFs), Early HP Calculators.</p> Scenario Preferred Approach Why? Standard Stack $O(N)$ Time. Natural fit for RPN."},{"location":"microsoft/01_evaluate_rpn/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Process each token once. Space $O(N)$ Stack depth."},{"location":"microsoft/01_evaluate_rpn/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>[\"2\", \"1\", \"+\", \"3\", \"*\"]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef stack fill:#f472b6,stroke:#db2777,stroke-width:2px,color:#0f172a\n\n    Init[Start] --&gt; Push2[\"Push 2: [2]\"]\n    Push2 --&gt; Push1[\"Push 1: [2, 1]\"]\n    Push1 --&gt; OpPlus[\"Op '+': Pop 1, 2. Calc 2+1=3. Push 3.\"]\n    OpPlus --&gt; Stack3[\"Stack: [3]\"]\n    Stack3 --&gt; Push3[\"Push 3: [3, 3]\"]\n    Push3 --&gt; OpMult[\"Op '*': Pop 3, 3. Calc 3*3=9. Push 9.\"]\n    OpMult --&gt; End[\"Result: 9\"]\n\n    class Push2,Push1,Stack3,Push3 stack</code></pre>"},{"location":"microsoft/01_evaluate_rpn/#solution","title":"Solution","text":"<pre><code>def eval_rpn(self, tokens: list[str]) -&gt; int:\n    stack = []\n    for token in tokens:\n        if token in \"+-*/\":\n            b = stack.pop()\n            a = stack.pop()\n            if token == \"+\": stack.append(a + b)\n            elif token == \"-\": stack.append(a - b)\n            elif token == \"*\": stack.append(a * b)\n            elif token == \"/\": stack.append(int(a / b))\n        else:\n            stack.append(int(token))\n    return stack[0]\n</code></pre>"},{"location":"microsoft/02_combination_sum_iii/","title":"Combination Sum III \ud83d\udfe1 Medium","text":"<p>Tags: <code>Backtracking</code>, <code>Array</code></p>"},{"location":"microsoft/02_combination_sum_iii/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Recursion (Backtracking) \ud83d\udfe1 Medium Critical Exploring combinations"},{"location":"microsoft/02_combination_sum_iii/#the-challenge","title":"The Challenge","text":"<p>Find all valid combinations of <code>k</code> numbers that sum up to <code>n</code> such that the following conditions are true: - Only numbers 1 through 9 are used. - Each number is used at most once.</p> <p>Constraints: - $2 \\leq k \\leq 9$ - $1 \\leq n \\leq 60$</p> <p>Example: <pre><code>Input: k = 3, n = 7\nOutput: [[1,2,4]]\n</code></pre></p>"},{"location":"microsoft/02_combination_sum_iii/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/02_combination_sum_iii/#optimal-approach-backtracking","title":"Optimal Approach (Backtracking)","text":"<p>Explore subset logic. - State: <code>(start_num, current_comb, current_sum)</code> - Boundaries:     - If <code>len == k</code> and <code>sum == n</code>: Add to valid.     - If <code>sum &gt; n</code> or <code>len &gt; k</code>: Prune. - Loop: <code>i</code> from <code>start_num</code> to 9.</p>"},{"location":"microsoft/02_combination_sum_iii/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Feature selection, Knapsack-like resource allocation.</p> Scenario Preferred Approach Why? Small Range Backtracking Input only 1-9. Search space is tiny ($2^9 = 512$ max). Very fast."},{"location":"microsoft/02_combination_sum_iii/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(C(9, k))$ Choosing k from 9 items. Space $O(k)$ Recursion depth."},{"location":"microsoft/02_combination_sum_iii/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>k=3, n=7</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef good fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n    classDef bad fill:#ef4444,stroke:#f87171,stroke-width:2px,color:#0f172a\n\n    Root[\"[] (sum=0)\"] --&gt; One[\"[1] (sum=1)\"]\n    One --&gt; OneTwo[\"[1, 2] (sum=3)\"]\n    OneTwo --&gt; OneTwoThree[\"[1, 2, 3] (sum=6)\"]\n    OneTwoThree --&gt; Fail1[\"Len=3, Sum!=7. Backtrack.\"]\n\n    OneTwo --&gt; OneTwoFour[\"[1, 2, 4] (sum=7)\"]\n    OneTwoFour --&gt; Success[\"Len=3, Sum=7. Add!\"]\n\n    class Success good\n    class Fail1 bad</code></pre>"},{"location":"microsoft/02_combination_sum_iii/#solution","title":"Solution","text":"<pre><code>def combination_sum_3(self, k: int, n: int) -&gt; list[list[int]]:\n    results = []\n    def backtrack(start: int, current_comb: list[int], current_sum: int):\n        if len(current_comb) == k:\n            if current_sum == n: results.append(list(current_comb))\n            return\n        if current_sum &gt; n: return\n\n        for i in range(start, 10):\n            current_comb.append(i)\n            backtrack(i + 1, current_comb, current_sum + i)\n            current_comb.pop()\n\n    backtrack(1, [], 0)\n    return results\n</code></pre>"},{"location":"microsoft/03_bulls_and_cows/","title":"Bulls and Cows \ud83d\udfe1 Medium","text":"<p>Tags: <code>Hash Table</code>, <code>String</code>, <code>Counting</code></p>"},{"location":"microsoft/03_bulls_and_cows/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Hash Map (Frequency) \ud83d\udfe2 Easy Critical Counting chars"},{"location":"microsoft/03_bulls_and_cows/#the-challenge","title":"The Challenge","text":"<p>You are playing the Bulls and Cows game with your friend.</p> <p>You write down a secret number and ask your friend to guess what the number is. When your friend makes a guess, you provide a hint with the following info: - The number of \"bulls\", which are digits in the guess that are in the correct position. - The number of \"cows\", which are digits in the guess that are in your secret number but are located in the wrong position.</p> <p>Given the secret number <code>secret</code> and your friend's guess <code>guess</code>, return the hint to your friend's guess.</p> <p>Constraints: - $1 \\leq secret.length, guess.length \\leq 1000$ - <code>secret</code> and <code>guess</code> consist of digits.</p> <p>Example: <pre><code>Input: secret = \"1807\", guess = \"7810\"\nOutput: \"1A3B\"\nExplanation: 1 Bull (8), 3 Cows (0, 1, 7).\n</code></pre></p>"},{"location":"microsoft/03_bulls_and_cows/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/03_bulls_and_cows/#optimal-approach-counter","title":"Optimal Approach (Counter)","text":"<p>Two pass or One pass. - Logic:     1. Bulls: Scan <code>i</code>. If <code>secret[i] == guess[i]</code>: <code>bulls++</code>. Remove from consideration.     2. Cows: Count remaining chars in secret and guess. For each char <code>c</code>, <code>cows += min(secret_count[c], guess_count[c])</code>.</p>"},{"location":"microsoft/03_bulls_and_cows/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Code breaking games (Wordle logic), fuzzy matching scoring.</p> Scenario Preferred Approach Why? Standard Two Pass $O(N)$. Clear separation of Bulls vs Cows logic."},{"location":"microsoft/03_bulls_and_cows/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single/Double pass. Space $O(1)$ Digits 0-9 counters (Size 10)."},{"location":"microsoft/03_bulls_and_cows/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>S=\"1807\", G=\"7810\"</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef bull fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n    classDef cow fill:#eab308,stroke:#facc15,stroke-width:2px,color:#0f172a\n\n    Scan[\"Scan Indices\"] --&gt; I0[\"i=0: S='1', G='7'. No Match.\"]\n    I0 --&gt; I1[\"i=1: S='8', G='8'. BULL!\"]\n    I1 --&gt; I2[\"i=2: S='0', G='1'. No Match.\"]\n    I2 --&gt; I3[\"i=3: S='7', G='0'. No Match.\"]\n\n    I3 --&gt; Count[\"Counts: S{1:1, 0:1, 7:1}, G{7:1, 1:1, 0:1}\"]\n    Count --&gt; Cow1[\"'1' in S? Yes. COW.\"]\n    Cow1 --&gt; Cow2[\"'0' in S? Yes. COW.\"]\n    Cow2 --&gt; Cow3[\"'7' in S? Yes. COW.\"]\n\n    class I1 bull\n    class Cow1,Cow2,Cow3 cow</code></pre>"},{"location":"microsoft/03_bulls_and_cows/#solution","title":"Solution","text":"<pre><code>def get_hint(self, secret: str, guess: str) -&gt; str:\n    bulls = 0\n    cows = 0\n    secret_counts = Counter(secret)\n    guess_counts = Counter(guess)\n\n    # Calculate Bulls\n    for s, g in zip(secret, guess):\n        if s == g:\n            bulls += 1\n            # Decrement counts so they aren't counted as cows\n            secret_counts[s] -= 1\n            guess_counts[g] -= 1\n\n    # Calculate Cows\n    for char, count in guess_counts.items():\n        if char in secret_counts:\n            # Cows is min of remaining available\n            cows += min(count, secret_counts[char])\n\n    return f\"{bulls}A{cows}B\"\n</code></pre>"},{"location":"microsoft/04_rotate_function/","title":"Rotate Function \ud83d\udfe1 Medium","text":"<p>Tags: <code>Math</code>, <code>Array</code>, <code>Dynamic Programming</code></p>"},{"location":"microsoft/04_rotate_function/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Mathematical Derivation \ud83d\udd34 Hard Critical Finding the recurrence relation"},{"location":"microsoft/04_rotate_function/#the-challenge","title":"The Challenge","text":"<p>You are given an integer array <code>nums</code> of length <code>n</code>.</p> <p>Assume <code>arr_k</code> to be an array obtained by rotating <code>nums</code> by <code>k</code> positions clock-wise. We define the rotation function <code>F</code> on <code>nums</code> as follows:</p> <p><code>F(k) = 0 * arr_k[0] + 1 * arr_k[1] + ... + (n - 1) * arr_k[n - 1]</code></p> <p>Return the maximum value of <code>F(0), F(1), ..., F(n-1)</code>.</p> <p>Constraints: - $n == nums.length$ - $1 \\leq n \\leq 10^5$</p> <p>Example: <pre><code>Input: nums = [4,3,2,6]\nOutput: 26\n</code></pre></p>"},{"location":"microsoft/04_rotate_function/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/04_rotate_function/#naive-approach","title":"Naive Approach","text":"<p>Calculate F(k) for each k independently. - Complexity: $O(N^2)$. - Fail: TLE on $N=10^5$.</p>"},{"location":"microsoft/04_rotate_function/#optimal-approach-mathematical-pattern","title":"Optimal Approach (Mathematical Pattern)","text":"<p>Derive $F(k)$ from $F(k-1)$. - $F(0) = 0 \\cdot A + 1 \\cdot B + 2 \\cdot C + 3 \\cdot D$ - $F(1) = 0 \\cdot D + 1 \\cdot A + 2 \\cdot B + 3 \\cdot C$ - Difference: $F(1) - F(0) = A + B + C - 3D$ - Generalization: $F(k) = F(k-1) + \\text{sum}(nums) - n \\times \\text{nums}[n-k]$ - Explanation: Every element shifts right (increasing coefficient by 1), except the last element which wraps to 0 (coefficient drops from $n-1$ to 0).</p>"},{"location":"microsoft/04_rotate_function/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Signal processing (convolution), sliding window calculations where window shifts cyclically.</p> Scenario Preferred Approach Why? Standard Math Derivation $O(N)$ Time. Reduces quadratic work to linear by finding pattern."},{"location":"microsoft/04_rotate_function/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ One pass to calc F(0), one pass for others. Space $O(1)$ Constant vars."},{"location":"microsoft/04_rotate_function/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>nums = [4, 3, 2, 6]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef state fill:#3b82f6,stroke:#60a5fa,stroke-width:2px,color:#0f172a\n\n    F0[\"F(0): 0*4 + 1*3 + 2*2 + 3*6 = 25\"] --&gt; F1[\"F(1)\"]\n\n    subgraph Transition\n    Calc[\"F(k) = F(k-1) + sum - n * last\"]\n    Details[\"F(1) = 25 + 15 - 4*6 = 16\"]\n    end\n\n    F0 --&gt; Transition\n    Transition --&gt; F1Result[\"F(1) = 16\"]\n    F1Result --&gt; F2[\"F(2) = 16 + 15 - 4*2 = 23\"]\n    F2 --&gt; F3[\"F(3) = 23 + 15 - 4*3 = 26\"]\n\n    class F3 state</code></pre>"},{"location":"microsoft/04_rotate_function/#solution","title":"Solution","text":"<pre><code>def rotate_function(self, nums: list[int]) -&gt; int:\n    n = len(nums)\n    s = sum(nums)\n    f_0 = sum(i * num for i, num in enumerate(nums))\n\n    max_f = f_0\n    current_f = f_0\n\n    for k in range(1, n):\n        # The element moving from end to start is nums[n-k]\n        current_f = current_f + s - n * nums[n - k]\n        max_f = max(max_f, current_f)\n\n    return max_f\n</code></pre>"},{"location":"microsoft/05_largest_divisible_subset/","title":"Largest Divisible Subset \ud83d\udfe1 Medium","text":"<p>Tags: <code>Dynamic Programming</code>, <code>Sorting</code>, <code>Math</code></p>"},{"location":"microsoft/05_largest_divisible_subset/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes LIS (Longest Increasing Subsequence) \ud83d\udfe1 Medium Critical Similar DP structure Sorting \ud83d\udfe2 Easy High Simples divisibility checks"},{"location":"microsoft/05_largest_divisible_subset/#the-challenge","title":"The Challenge","text":"<p>Given a set of distinct positive integers <code>nums</code>, return the largest subset <code>answer</code> such that every pair <code>(answer[i], answer[j])</code> of elements in this subset satisfies: - <code>answer[i] % answer[j] == 0</code>, or - <code>answer[j] % answer[i] == 0</code></p> <p>Constraints: - $1 \\leq nums.length \\leq 1000$</p> <p>Example: <pre><code>Input: nums = [1,2,3]\nOutput: [1,2] (or [1,3])\n</code></pre></p>"},{"location":"microsoft/05_largest_divisible_subset/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/05_largest_divisible_subset/#optimal-approach-sorting-dp","title":"Optimal Approach (Sorting + DP)","text":"<p>If <code>a &lt; b &lt; c</code> and <code>b % a == 0</code> and <code>c % b == 0</code>, then <code>c % a == 0</code> (transitivity). 1. Sort <code>nums</code>: Ensures we only check <code>nums[i] % nums[j] == 0</code> for $j &lt; i$. 2. DP State: <code>dp[i]</code> = size of largest divisible subset ending at index <code>i</code>. 3. Transition: $dp[i] = \\max(dp[j] + 1)$ for all $j &lt; i$ where <code>nums[i] % nums[j] == 0</code>. 4. Reconstruction: Track <code>prev[i]</code> to rebuild the subset.</p>"},{"location":"microsoft/05_largest_divisible_subset/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Resource scheduling (compatible time slots), Cryptography (coprime vs divisible keys).</p> Scenario Preferred Approach Why? Standard Sort + DP $O(N^2)$. Similar to LIS, but condition is modulo."},{"location":"microsoft/05_largest_divisible_subset/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N^2)$ Double loop for DP. Space $O(N)$ DP array and Prev array."},{"location":"microsoft/05_largest_divisible_subset/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>nums = [1, 2, 4, 8]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef dp fill:#8b5cf6,stroke:#a78bfa,stroke-width:2px,color:#0f172a\n\n    Start[\"Sort: [1, 2, 4, 8]\"] --&gt; DP1[\"i=0 (1): dp[0]=1\"]\n    DP1 --&gt; DP2[\"i=1 (2): 2%1==0. dp[1] = dp[0]+1 = 2\"]\n    DP2 --&gt; DP3[\"i=2 (4): 4%2==0. dp[2] = dp[1]+1 = 3\"]\n    DP3 --&gt; DP4[\"i=3 (8): 8%4==0. dp[3] = dp[2]+1 = 4\"]\n\n    DP4 --&gt; Trace[\"Backtrack Max index 3 (8) -&gt; 4 -&gt; 2 -&gt; 1\"]\n\n    class DP4 dp</code></pre>"},{"location":"microsoft/05_largest_divisible_subset/#solution","title":"Solution","text":"<pre><code>def largest_divisible_subset(self, nums: list[int]) -&gt; list[int]:\n    if not nums: return []\n    nums.sort()\n    n = len(nums)\n    dp = [1] * n\n    prev = [-1] * n\n\n    max_size = 1\n    max_index = 0\n\n    for i in range(1, n):\n        for j in range(i):\n            if nums[i] % nums[j] == 0:\n                if dp[i] &lt; dp[j] + 1:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n\n        if dp[i] &gt; max_size:\n            max_size = dp[i]\n            max_index = i\n\n    result = []\n    curr = max_index\n    while curr != -1:\n        result.append(nums[curr])\n        curr = prev[curr]\n\n    return result[::-1]\n</code></pre>"},{"location":"microsoft/06_perfect_rectangle/","title":"Perfect Rectangle \ud83d\udd34 Hard","text":"<p>Tags: <code>Geometry</code>, <code>Math</code>, <code>Sweep Line</code></p>"},{"location":"microsoft/06_perfect_rectangle/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Coordinate Geometry \ud83d\udfe2 Easy High Bounding box logic"},{"location":"microsoft/06_perfect_rectangle/#the-challenge","title":"The Challenge","text":"<p>Given an array <code>rectangles</code> where <code>rectangles[i] = [x1, y1, x2, y2]</code>, return <code>true</code> if all the rectangles together form an exact rectangular region.</p> <p>Constraints: - $1 \\leq rectangles.length \\leq 2 \\times 10^4$</p> <p>Example: <pre><code>Input: rectangles = [[1,1,3,3],[3,1,4,2],[3,2,4,4],[1,3,2,4],[2,3,3,4]]\nOutput: true\n</code></pre></p>"},{"location":"microsoft/06_perfect_rectangle/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/06_perfect_rectangle/#naive-approach","title":"Naive Approach","text":"<p>Bitmap / Grid approximation.  - Fail: Coordinates are huge (infinity).</p>"},{"location":"microsoft/06_perfect_rectangle/#optimal-approach-area-corners","title":"Optimal Approach (Area + Corners)","text":"<p>Two necessary and sufficient conditions: 1. Area: Sum of all areas equals area of bounding box ($MaxX - MinX \\times MaxY - MinY$). 2. Corners:     - All inner corners must overlap pairwise or quad-wise to cancel out.     - Only the 4 outer corners of the bounding box should remain after cancellation.     - We use a set to track corners. A corner is \"odd\" if it appears 1 or 3 times. We want exactly 4 corners with count 1 corresponding to the bounding box. (Usually simplified to XOR or Set toggle: if present remove, else add).</p>"},{"location":"microsoft/06_perfect_rectangle/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: VLSI Design (chip floorplanning), UI Window Managers.</p> Scenario Preferred Approach Why? Standard Corner Counting $O(N)$. Mathematically elegant and robust."},{"location":"microsoft/06_perfect_rectangle/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass. Space $O(N)$ Corner set max size 4N."},{"location":"microsoft/06_perfect_rectangle/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>[[1,1,3,3], [3,1,4,2], ...]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef corner fill:#f472b6,stroke:#db2777,stroke-width:2px,color:#0f172a\n\n    Sub1[\"Rect1 (1,1)-(3,3) adds 4 corners\"] --&gt; Sub2[\"Rect2 (3,1)-(4,2) adds 4 corners\"]\n    Sub2 --&gt; Overlap[\"(3,1) appears in both. Cancel out?\"]\n\n    Logic[\"Logic: XOR Corners\"]\n    Overlap --&gt; Check[\"Final Set Size == 4?\"]\n    Check --&gt; Bounds[\"Final Set == Bounding Box Corners?\"]\n\n    class Check corner</code></pre>"},{"location":"microsoft/06_perfect_rectangle/#solution","title":"Solution","text":"<pre><code>def is_rectangle_cover(self, rectangles: list[list[int]]) -&gt; bool:\n    area = 0\n    corners = set()\n    min_x, min_y = float('inf'), float('inf')\n    max_x, max_y = float('-inf'), float('-inf')\n\n    for x1, y1, x2, y2 in rectangles:\n        area += (x2 - x1) * (y2 - y1)\n        min_x, min_y = min(min_x, x1), min(min_y, y1)\n        max_x, max_y = max(max_x, x2), max(max_y, y2)\n\n        for p in [(x1, y1), (x1, y2), (x2, y1), (x2, y2)]:\n            if p in corners: corners.remove(p)\n            else: corners.add(p)\n\n    if area != (max_x - min_x) * (max_y - min_y):\n        return False\n\n    return corners == {(min_x, min_y), (min_x, max_y), (max_x, min_y), (max_x, max_y)}\n</code></pre>"},{"location":"microsoft/07_course_schedule/","title":"Course Schedule \ud83d\udfe1 Medium","text":"<p>Tags: <code>Graph</code>, <code>DFS</code>, <code>Topological Sort</code></p>"},{"location":"microsoft/07_course_schedule/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Directed Graphs \ud83d\udfe2 Easy Critical Edges = Prerequisites Cycle Detection \ud83d\udfe1 Medium Critical Core logic"},{"location":"microsoft/07_course_schedule/#the-challenge","title":"The Challenge","text":"<p>There are <code>numCourses</code> courses you have to take available. Some have prerequisites. Return <code>true</code> if you can finish all courses.</p> <p>Constraints: - $1 \\leq numCourses \\leq 2000$</p> <p>Example: <pre><code>Input: numCourses = 2, prerequisites = [[1,0]]\nOutput: true (Take 0 then 1)\n</code></pre></p>"},{"location":"microsoft/07_course_schedule/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/07_course_schedule/#optimal-approach-dfs-kahns-algo","title":"Optimal Approach (DFS / Kahn's Algo)","text":"<p>Detect cycle in directed graph. - DFS: 3-Coloring.     - 0: Unvisited.     - 1: Visiting (in current recursion stack).     - 2: Visited (safe).     - If valid node leads to 1, CYCLE detected. - Kahn's (BFS):     - Track in-degrees.     - Queue nodes with 0 in-degree.     - If processed nodes &lt; total, CYCLE exists.</p>"},{"location":"microsoft/07_course_schedule/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Package dependency managers (pip, npm), Build systems (Make), Task Scheduling.</p> Scenario Preferred Approach Why? Standard DFS $O(V+E)$. Easy to implement recursively. Need Order Kahn's Naturally produces the topological sort list if valid."},{"location":"microsoft/07_course_schedule/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(V + E)$ Visit every node and edge. Space $O(V + E)$ Adjacency list + Recursion stack."},{"location":"microsoft/07_course_schedule/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>2 courses, [[1,0]]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef safe fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n    classDef visit fill:#eab308,stroke:#facc15,stroke-width:2px,color:#0f172a\n\n    Start[\"Check(0)\"] --&gt; Visit0[\"State[0] = Visiting\"]\n    Visit0 --&gt; Check1[\"Check(1)? No outgoing.\"]\n    Check1 --&gt; Safe1[\"State[1] = Safe\"]\n    Safe1 --&gt; Back[\"Back to 0\"]\n    Back --&gt; Safe0[\"State[0] = Safe\"]\n\n    class Safe0 safe\n    class Visit0 visit</code></pre>"},{"location":"microsoft/07_course_schedule/#solution","title":"Solution","text":"<pre><code>def can_finish(self, num_courses: int, prerequisites: list[list[int]]) -&gt; bool:\n    adj = [[] for _ in range(num_courses)]\n    for course, pre in prerequisites:\n        adj[pre].append(course)\n\n    state = [0] * num_courses\n\n    def has_cycle(node):\n        if state[node] == 1: return True\n        if state[node] == 2: return False\n\n        state[node] = 1\n        for neighbor in adj[node]:\n            if has_cycle(neighbor): return True\n        state[node] = 2\n        return False\n\n    for i in range(num_courses):\n        if has_cycle(i): return False\n    return True\n</code></pre>"},{"location":"microsoft/08_most_profitable_path/","title":"Most Profitable Path in a Tree \ud83d\udfe1 Medium","text":"<p>Tags: <code>Tree</code>, <code>DFS</code>, <code>BFS</code></p>"},{"location":"microsoft/08_most_profitable_path/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Graph Traversal \ud83d\udfe2 Easy Critical Finding paths and arrival times"},{"location":"microsoft/08_most_profitable_path/#the-challenge","title":"The Challenge","text":"<p>Alice starts at 0, Bob starts at <code>bob</code> node. - Alice moves to a leaf node to max net income. - Bob moves to 0. - <code>amount[i]</code> is cost (neg) or reward (pos). - If they reach node same time, split cost/reward. - If one arrives earlier, they take/pay full. Return max net income for Alice.</p> <p>Constraints: - $2 \\leq n \\leq 10^5$</p>"},{"location":"microsoft/08_most_profitable_path/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/08_most_profitable_path/#optimal-approach-two-pass","title":"Optimal Approach (Two Pass)","text":"<ol> <li>Map Bob: Find Bob's path to 0 using DFS/BFS. Record <code>arrival_time[node]</code> for Bob.</li> <li>Alice Search: DFS from 0 to leaves.<ul> <li>Track <code>curr_time</code> and <code>curr_income</code>.</li> <li>At each node, check Bob's time vs Alice's time.<ul> <li>Alice &lt; Bob: Alice gets full amount.</li> <li>Alice == Bob: Split amount.</li> <li>Alice &gt; Bob: 0 amount (taken).</li> </ul> </li> <li>If Leaf, update global max.</li> </ul> </li> </ol>"},{"location":"microsoft/08_most_profitable_path/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Game theory simulation, network routing with competitive interference.</p>"},{"location":"microsoft/08_most_profitable_path/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Two traversals. Space $O(N)$ Tree storage."},{"location":"microsoft/08_most_profitable_path/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>Bob starts at 1, Alice at 0</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef bob fill:#ef4444,stroke:#f87171,stroke-width:2px,color:#0f172a\n    classDef alice fill:#3b82f6,stroke:#60a5fa,stroke-width:2px,color:#0f172a\n\n    Time0[\"Time 0\"] --&gt; BobMove[\"Bob at 1. Dist to 0 is 1.\"]\n    Time0 --&gt; AliceMove[\"Alice at 0. Income += Amt[0]\"]\n\n    Time1[\"Time 1\"] --&gt; BobArrive[\"Bob arrives at 0.\"]\n    Time1 --&gt; AliceArrive[\"Alice arrives at 1.\"]\n\n    Conflict[\"Both at 0? No. 0 visited by Alice(t=0), Bob(t=1).\"]\n    Split[\"At node 1? Alice(t=1), Bob(t=0).\"]\n    Rule[\"Logic: Who arrived first?\"]\n\n    class BobMove bob\n    class AliceMove alice</code></pre>"},{"location":"microsoft/08_most_profitable_path/#solution","title":"Solution","text":"<pre><code>def most_profitable_path(self, edges: list[list[int]], bob: int, amount: list[int]) -&gt; int:\n    n = len(amount)\n    adj = [[] for _ in range(n)]\n    for u, v in edges:\n        adj[u].append(v); adj[v].append(u)\n\n    bob_time = {}\n    def find_bob(node, time, visited):\n        bob_time[node] = time\n        if node == 0: return True\n        visited.add(node)\n        for nei in adj[node]:\n            if nei not in visited:\n                if find_bob(nei, time + 1, visited): return True\n        del bob_time[node]\n        return False\n    find_bob(bob, 0, set())\n\n    max_profit = float('-inf')\n    visited = [False] * n\n    def solve_alice(node, time, curr_profit):\n        nonlocal max_profit\n        visited[node] = True\n\n        # Calculate Income\n        inc = 0\n        if node not in bob_time or time &lt; bob_time[node]: inc = amount[node]\n        elif time == bob_time[node]: inc = amount[node] // 2\n\n        curr_profit += inc\n\n        is_leaf = True\n        for nei in adj[node]:\n            if not visited[nei]:\n                is_leaf = False\n                solve_alice(nei, time + 1, curr_profit)\n\n        if is_leaf: max_profit = max(max_profit, curr_profit)\n\n    solve_alice(0, 0, 0)\n    return int(max_profit)\n</code></pre>"},{"location":"microsoft/09_pairs_inequality/","title":"Number of Pairs Satisfying Inequality \ud83d\udd34 Hard","text":"<p>Tags: <code>Merge Sort</code>, <code>Segment Tree</code>, <code>BIT</code></p>"},{"location":"microsoft/09_pairs_inequality/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Merge Sort \ud83d\udfe1 Medium Critical Modified merge step"},{"location":"microsoft/09_pairs_inequality/#the-challenge","title":"The Challenge","text":"<p>Given two 0-indexed integer arrays <code>nums1</code> and <code>nums2</code>, and an integer <code>diff</code>, return the number of pairs <code>(i, j)</code> such that: - $0 \\leq i &lt; j \\leq n - 1$ - $nums1[i] - nums1[j] \\leq nums2[i] - nums2[j] + diff$</p> <p>Constraints: - $n == nums1.length == nums2.length$ - $2 \\leq n \\leq 10^5$</p>"},{"location":"microsoft/09_pairs_inequality/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/09_pairs_inequality/#naive-approach","title":"Naive Approach","text":"<p>Check all pairs. $O(N^2)$. - Fail: $N=10^5$ leads to TLE.</p>"},{"location":"microsoft/09_pairs_inequality/#optimal-approach-rearrangement-merge-sort","title":"Optimal Approach (Rearrangement + Merge Sort)","text":"<p>Rewrite inequality: $(nums1[i] - nums2[i]) \\leq (nums1[j] - nums2[j]) + diff$ Let $d[k] = nums1[k] - nums2[k]$. Find pairs $(i, j)$ where $i &lt; j$ and $d[i] \\leq d[j] + diff$. This is \"Count Pairs with Condition\" solvable via Merge Sort (like Inversion Count). - During merge of <code>Left</code> and <code>Right</code>:     - For element <code>x</code> in <code>Left</code>, count valid <code>y</code> in <code>Right</code>.     - Since <code>Right</code> is sorted, we can find split point efficiently.</p>"},{"location":"microsoft/09_pairs_inequality/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Statistical analysis (rank correlation), specialized database joins.</p>"},{"location":"microsoft/09_pairs_inequality/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\log N)$ Merge sort. Space $O(N)$ Merge sort auxiliary array."},{"location":"microsoft/09_pairs_inequality/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>nums1=[3,2,5], nums2=[2,2,1], diff=1</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef merge fill:#8b5cf6,stroke:#a78bfa,stroke-width:2px,color:#0f172a\n\n    Diffs[\"Calc Diffs: [3-2, 2-2, 5-1] = [1, 0, 4]\"] --&gt; Sort[\"Merge Sort [1, 0, 4]\"]\n\n    Split[\"Split [1] and [0, 4]\"]\n    Merge[\"Merge: Left=[1], Right=[0, 4]\"]\n    Check[\"For x=1: Count y in [0, 4] where 1 &lt;= y+1\"]\n    Logic[\"1 &lt;= 0+1 (True, y=0). 1 &lt;= 4+1 (True, y=4). Count+=2\"]\n\n    class Merge merge</code></pre>"},{"location":"microsoft/09_pairs_inequality/#solution","title":"Solution","text":"<pre><code>def number_of_pairs(self, nums1: list[int], nums2: list[int], diff: int) -&gt; int:\n    d = [n1 - n2 for n1, n2 in zip(nums1, nums2)]\n    def merge_sort(arr):\n        if len(arr) &lt;= 1: return arr, 0\n        mid = len(arr) // 2\n        left, l_cnt = merge_sort(arr[:mid])\n        right, r_cnt = merge_sort(arr[mid:])\n        count = l_cnt + r_cnt\n\n        # Count Step\n        r_idx = 0\n        for x in left:\n            while r_idx &lt; len(right) and right[r_idx] &lt; x - diff:\n                r_idx += 1\n            count += len(right) - r_idx\n\n        # Merge Step\n        sorted_arr = []\n        i = j = 0\n        while i &lt; len(left) and j &lt; len(right):\n            if left[i] &lt;= right[j]:\n                sorted_arr.append(left[i]); i += 1\n            else:\n                sorted_arr.append(right[j]); j += 1\n        sorted_arr.extend(left[i:]); sorted_arr.extend(right[j:])\n        return sorted_arr, count\n\n    _, total = merge_sort(d)\n    return total\n</code></pre>"},{"location":"microsoft/10_shortest_unsorted_subarray/","title":"Shortest Unsorted Continuous Subarray \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Sorting</code>, <code>Two Pointers</code></p>"},{"location":"microsoft/10_shortest_unsorted_subarray/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Array Scanning \ud83d\udfe2 Easy Critical Finding min/max out of order"},{"location":"microsoft/10_shortest_unsorted_subarray/#the-challenge","title":"The Challenge","text":"<p>Given an integer array <code>nums</code>, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order. Return the shortest such subarray and output its length.</p> <p>Constraints: - $1 \\leq nums.length \\leq 10^4$</p> <p>Example: <pre><code>Input: nums = [2,6,4,8,10,9,15]\nOutput: 5\nExplanation: [6, 4, 8, 10, 9] needs sorting.\n</code></pre></p>"},{"location":"microsoft/10_shortest_unsorted_subarray/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/10_shortest_unsorted_subarray/#naive-approach-sorting","title":"Naive Approach (Sorting)","text":"<p>Sort copy <code>s_nums</code>. Compare <code>nums[i] != s_nums[i]</code>. Find first and last mismatch. - Complexity: $O(N \\log N)$. - Space: $O(N)$.</p>"},{"location":"microsoft/10_shortest_unsorted_subarray/#optimal-approach-one-pass","title":"Optimal Approach (One Pass)","text":"<ol> <li>Find the element from left that is smaller than <code>max_so_far</code>. This marks the <code>end</code> of disorder.</li> <li>Find the element from right that is bigger than <code>min_so_far</code>. This marks the <code>start</code> of disorder.</li> <li>Explanation: If <code>nums[i]</code> is smaller than max on its left, it MUST be rearranged.</li> </ol>"},{"location":"microsoft/10_shortest_unsorted_subarray/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Data cleaning (identifying corrupted segments), partially sorted data optimization.</p> Scenario Preferred Approach Why? Standard Two Pass $O(N)$. Linear time is optimal."},{"location":"microsoft/10_shortest_unsorted_subarray/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Two linear scans. Space $O(1)$ Constant variables."},{"location":"microsoft/10_shortest_unsorted_subarray/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>[2, 6, 4, 8, 10, 9, 15]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef bad fill:#ef4444,stroke:#f87171,stroke-width:2px,color:#0f172a\n\n    ScanL[\"Left Scan Max\"] --&gt; Max6[\"Max=6\"]\n    Max6 --&gt; Check4[\"4 &lt; 6? Yes. End = Index(2).\"]\n    Check4 --&gt; Max8[\"Max=8\"]\n    Max8 --&gt; Check10[\"Max=10\"]\n    Check10 --&gt; Check9[\"9 &lt; 10? Yes. End = Index(5).\"]\n\n    ScanR[\"Right Scan Min\"] --&gt; Min9[\"Min=9\"]\n    Min9 --&gt; Check10R[\"10 &gt; 9? Yes. Start = Index(4).\"]\n    Check10R --&gt; Check8[\"Min=8\"]\n    Check8 --&gt; Check4R[\"Min=4\"]\n    Check4R --&gt; Check6[\"6 &gt; 4? Yes. Start = Index(1).\"]\n\n    Result[\"Range [1, 5] (Length 5)\"]\n    class Check9,Check6 bad</code></pre>"},{"location":"microsoft/10_shortest_unsorted_subarray/#solution","title":"Solution","text":"<pre><code>def find_unsorted_subarray(self, nums: list[int]) -&gt; int:\n    n = len(nums)\n    if n &lt;= 1: return 0\n\n    end = -2\n    max_so_far = float('-inf')\n    for i in range(n):\n        max_so_far = max(max_so_far, nums[i])\n        if nums[i] &lt; max_so_far: end = i\n\n    start = -1\n    min_so_far = float('inf')\n    for i in range(n - 1, -1, -1):\n        min_so_far = min(min_so_far, nums[i])\n        if nums[i] &gt; min_so_far: start = i\n\n    if end == -2: return 0\n    return end - start + 1\n</code></pre>"},{"location":"microsoft/11_ways_arrive_destination/","title":"Number of Ways to Arrive at Destination \ud83d\udfe1 Medium","text":"<p>Tags: <code>Graph</code>, <code>Dijkstra</code>, <code>Dynamic Programming</code></p>"},{"location":"microsoft/11_ways_arrive_destination/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Dijkstra's Algo \ud83d\udfe1 Medium Critical Shortest Path Modular Arithmetic \ud83d\udfe2 Easy High Result modulo $10^9+7$"},{"location":"microsoft/11_ways_arrive_destination/#the-challenge","title":"The Challenge","text":"<p>You are in a city that consists of <code>n</code> intersections numbered from <code>0</code> to <code>n - 1</code> with bi-directional roads between some intersections. The inputs are generated such that you can reach any intersection from any other intersection and that there is at most one road between any two intersections.</p> <p>You want to know the number of ways you can travel from intersection <code>0</code> to intersection <code>n - 1</code> in the shortest amount of time.</p> <p>Constraints: - $1 \\leq n \\leq 200$ - $0 \\leq time_i \\leq 10^9$</p> <p>Example: <pre><code>Input: n = 7, roads = [[0,6,7],[0,1,2],[1,2,3],[1,3,3],[6,3,3],[3,5,1],[6,5,1],[2,5,1],[0,4,5],[4,6,2]]\nOutput: 4\n</code></pre></p>"},{"location":"microsoft/11_ways_arrive_destination/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/11_ways_arrive_destination/#optimal-approach-dijkstra-dp","title":"Optimal Approach (Dijkstra + DP)","text":"<p>Standard Dijkstra finds the shortest time. We need to count how many paths match this time. - <code>dist[v]</code>: Min time to reach <code>v</code>. - <code>ways[v]</code>: Number of ways to reach <code>v</code> with time <code>dist[v]</code>. - Relaxation Logic:     - If <code>new_time &lt; dist[v]</code>:         - <code>dist[v] = new_time</code>         - <code>ways[v] = ways[u]</code> (Inherit count)         - Push to Heap.     - If <code>new_time == dist[v]</code>:         - <code>ways[v] += ways[u]</code> (Add paths)         - Do NOT push (Optimization: node already in queue or processed).</p>"},{"location":"microsoft/11_ways_arrive_destination/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: GPS routing (alternative equally fast routes), Network packet routing load balancing.</p>"},{"location":"microsoft/11_ways_arrive_destination/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(E \\log V)$ Dijkstra standard. Space $O(V + E)$ Graph storage + Heap."},{"location":"microsoft/11_ways_arrive_destination/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>0-&gt;(1,2), 1-&gt;(2,3)... End=2</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef path fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Start(\"Start 0 (Dist=0, Ways=1)\") --&gt; P1(\"Node 1 (Cost 2)\")\n    Start --&gt; P2(\"Node 2 (Cost 5)\")\n\n    P1 --&gt; P3(\"Node 2 via 1 (Cost 2+3=5)\")\n    P2 --&gt; Compare{\"Compare Dist to 2\"}\n    P3 --&gt; Compare\n\n    Compare --&gt; Logic[\"5 == 5. Ways[2] += Ways[1]\"]\n    Logic --&gt; Result[\"Dist[2]=5, Ways[2] = 1 (direct) + 1 (via 1) = 2\"]\n\n    class Result path</code></pre>"},{"location":"microsoft/11_ways_arrive_destination/#solution","title":"Solution","text":"<pre><code>def count_paths(self, n: int, roads: list[list[int]]) -&gt; int:\n    import heapq\n    MOD = 10**9 + 7\n\n    adj = [[] for _ in range(n)]\n    for u, v, t in roads:\n        adj[u].append((v, t)); adj[v].append((u, t))\n\n    dist = [float('inf')] * n\n    ways = [0] * n\n    dist[0] = 0; ways[0] = 1\n\n    pq = [(0, 0)] # time, node\n\n    while pq:\n        d, u = heapq.heappop(pq)\n        if d &gt; dist[u]: continue\n\n        for v, time in adj[u]:\n            new_dist = d + time\n            if new_dist &lt; dist[v]:\n                dist[v] = new_dist\n                ways[v] = ways[u]\n                heapq.heappush(pq, (new_dist, v))\n            elif new_dist == dist[v]:\n                ways[v] = (ways[v] + ways[u]) % MOD\n\n    return ways[n - 1]\n</code></pre>"},{"location":"microsoft/12_longest_happy_prefix/","title":"Longest Happy Prefix \ud83d\udd34 Hard","text":"<p>Tags: <code>String</code>, <code>KMP</code>, <code>Rolling Hash</code></p>"},{"location":"microsoft/12_longest_happy_prefix/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes KMP Algorithm \ud83d\udd34 Hard Critical LPS Array conceptualization"},{"location":"microsoft/12_longest_happy_prefix/#the-challenge","title":"The Challenge","text":"<p>A string is called a happy prefix if is a non-empty prefix which is also a suffix (excluding itself). Given a string <code>s</code>, return the longest happy prefix of <code>s</code>. Return an empty string if no such prefix exists.</p> <p>Constraints: - $1 \\leq s.length \\leq 10^5$</p> <p>Example: <pre><code>Input: s = \"level\"\nOutput: \"l\" (Prefix \"l\", Suffix \"l\")\nInput: s = \"ababab\"\nOutput: \"abab\" (Prefix \"abab\", Suffix \"abab\")\n</code></pre></p>"},{"location":"microsoft/12_longest_happy_prefix/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/12_longest_happy_prefix/#naive-approach","title":"Naive Approach","text":"<p>Check length $N-1$ down to $1$. - <code>if s[:k] == s[N-k:]</code>. - String slice cost depends on implementation, usually $O(k)$. Total $O(N^2)$. - Fail: TLE.</p>"},{"location":"microsoft/12_longest_happy_prefix/#optimal-approach-kmp-lps-array","title":"Optimal Approach (KMP / LPS Array)","text":"<p>The \"Longest Prefix which is also a Suffix\" is literally the definition of the LPS array in the Knuth-Morris-Pratt algorithm. - Calculate LPS array for the whole string. - <code>LPS[n-1]</code> gives the length of the longest proper prefix that is also a suffix.</p>"},{"location":"microsoft/12_longest_happy_prefix/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: DNA Sequencing (overlapping fragments assembly), Data Compression (LZ77).</p>"},{"location":"microsoft/12_longest_happy_prefix/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ KMP LPS construction. Space $O(N)$ LPS array."},{"location":"microsoft/12_longest_happy_prefix/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>s = \"ababab\"</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef lps fill:#3b82f6,stroke:#60a5fa,stroke-width:2px,color:#0f172a\n\n    Idx0[\"i=0: LPS[0]=0\"] --&gt; Idx1[\"i=1: 'b'!='a'. LPS[1]=0\"]\n    Idx1 --&gt; Idx2[\"i=2: 'a'=='a'(len=0). Len=1. LPS[2]=1\"]\n    Idx2 --&gt; Idx3[\"i=3: 'b'=='b'(len=1). Len=2. LPS[3]=2\"]\n    Idx3 --&gt; Idx4[\"i=4: 'a'=='a'(len=2). Len=3. LPS[4]=3\"]\n    Idx4 --&gt; Idx5[\"i=5: 'b'=='b'(len=3). Len=4. LPS[5]=4\"]\n\n    Result[\"LPS[5]=4. Prefix s[:4] = 'abab'\"]\n    class Result lps</code></pre>"},{"location":"microsoft/12_longest_happy_prefix/#solution","title":"Solution","text":"<pre><code>def longest_prefix(self, s: str) -&gt; str:\n    n = len(s)\n    lps = [0] * n\n    length = 0\n    i = 1\n\n    while i &lt; n:\n        if s[i] == s[length]:\n            length += 1\n            lps[i] = length\n            i += 1\n        else:\n            if length != 0:\n                length = lps[length - 1]\n            else:\n                lps[i] = 0\n                i += 1\n\n    return s[:lps[n - 1]]\n</code></pre>"},{"location":"microsoft/13_seat_reservation_manager/","title":"Seat Reservation Manager \ud83d\udfe1 Medium","text":"<p>Tags: <code>Heap</code>, <code>Design</code></p>"},{"location":"microsoft/13_seat_reservation_manager/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Min-Heap \ud83d\udfe2 Easy Critical Getting smallest available seat"},{"location":"microsoft/13_seat_reservation_manager/#the-challenge","title":"The Challenge","text":"<p>Design a system that manages the reservation state of <code>n</code> seats, numbered <code>1</code> to <code>n</code>.</p> <p>Implement the <code>SeatManager</code> class: - <code>SeatManager(int n)</code> Initializes a <code>SeatManager</code> object that will manage <code>n</code> seats numbered <code>1</code> to <code>n</code>. All seats are initially available. - <code>int reserve()</code> Fetches the smallest-numbered unreserved seat, reserves it, and returns its number. - <code>void unreserve(int seatNumber)</code> Unreserves the seat with the given <code>seatNumber</code>.</p> <p>Constraints: - $1 \\leq n \\leq 10^5$ - At most $10^5$ calls to reserve/unreserve.</p>"},{"location":"microsoft/13_seat_reservation_manager/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/13_seat_reservation_manager/#optimal-approach-min-heap","title":"Optimal Approach (Min-Heap)","text":"<p>Keep track of available seats in a min-heap. - Init: Heap containing <code>1..n</code>. - Reserve: Pop min. - Unreserve: Push back seat number. - Optimization: Since initialized sorted, we can use a counter <code>min_available</code> and only add logic to heap for unreserved seats to save space?     - Classic Approach: Heap everything. Simple.     - Optimized: <code>min_pointer</code>. If Heap has items, pop Heap. Else use <code>min_pointer</code> and increment. When unreserving, only add to Heap if <code>seat &lt; min_pointer</code>. (Not strictly needed given N limit).</p>"},{"location":"microsoft/13_seat_reservation_manager/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Movie ticket booking, Resource ID allocation (File descriptors, process IDs).</p>"},{"location":"microsoft/13_seat_reservation_manager/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(\\log N)$ Heap push/pop. Space $O(N)$ Storing available seats."},{"location":"microsoft/13_seat_reservation_manager/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>N=5</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef heap fill:#facc15,stroke:#eab308,stroke-width:2px,color:#0f172a\n\n    Init[\"Init Heap: [1, 2, 3, 4, 5]\"] --&gt; Res1[\"Reserve() -&gt; Pop 1\"]\n    Res1 --&gt; State1[\"Heap: [2, 3, 4, 5]\"]\n    State1 --&gt; Res2[\"Reserve() -&gt; Pop 2\"]\n    Res2 --&gt; State2[\"Heap: [3, 4, 5]\"]\n\n    State2 --&gt; Unn2[\"Unreserve(2) -&gt; Push 2\"]\n    Unn2 --&gt; State3[\"Heap: [2, 3, 4, 5] (Sorted logic)\"]\n\n    class State3 heap</code></pre>"},{"location":"microsoft/13_seat_reservation_manager/#solution","title":"Solution","text":"<pre><code>class SeatManager:\n    def __init__(self, n: int):\n        import heapq\n        self.seats = list(range(1, n + 1))\n        heapq.heapify(self.seats)\n\n    def reserve(self) -&gt; int:\n        import heapq\n        return heapq.heappop(self.seats)\n\n    def unreserve(self, seat_number: int) -&gt; None:\n        import heapq\n        heapq.heappush(self.seats, seat_number)\n</code></pre>"},{"location":"microsoft/14_rotate_image/","title":"Rotate Image \ud83d\udfe1 Medium","text":"<p>Tags: <code>Matrix</code>, <code>Math</code></p>"},{"location":"microsoft/14_rotate_image/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Linear Algebra \ud83d\udfe2 Easy High Matrix Transposition"},{"location":"microsoft/14_rotate_image/#the-challenge","title":"The Challenge","text":"<p>You are given an <code>n x n</code> 2D matrix representing an image, rotate the image by 90 degrees (clockwise). You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</p> <p>Constraints: - $1 \\leq n \\leq 20$</p> <p>Example: <pre><code>Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [[7,4,1],[8,5,2],[9,6,3]]\n</code></pre></p>"},{"location":"microsoft/14_rotate_image/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/14_rotate_image/#optimal-approach-transpose-reverse","title":"Optimal Approach (Transpose + Reverse)","text":"<p>Mathematically, rotating 90 deg clockwise is equivalent to: 1. Transpose: Flip over main diagonal ($A[i][j] \\leftrightarrow A[j][i]$). 2. Reverse Rows: $[1, 2, 3] \\rightarrow [3, 2, 1]$.</p> <p>Example: <code>[1, 2] -&gt; (T) -&gt; [1, 3] -&gt; (Rev) -&gt; [3, 1]</code> <code>[3, 4]           [2, 4]              [4, 2]</code> Original <code>1</code> at <code>(0,0)</code> moves to <code>(0,1)</code> (Rev) which is 90 deg? Wait. Original: 1 2 3 4</p> <p>Target 90 (Clockwise): 3 1 4 2</p> <p>Transpose: 1 3 2 4</p> <p>Reverse Rows: 3 1 4 2 Correct.</p>"},{"location":"microsoft/14_rotate_image/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Image editors (Photo rotation), Graphics rendering pipelines.</p>"},{"location":"microsoft/14_rotate_image/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N^2)$ Visit every cell twice. Space $O(1)$ In-place."},{"location":"microsoft/14_rotate_image/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>[[1,2],[3,4]]</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef matrix fill:#a855f7,stroke:#c084fc,stroke-width:2px,color:#0f172a\n\n    Start[\"Start:\n    1 2\n    3 4\"]\n\n    Start --&gt; Transpose[\"Transpose (Swap i,j):\n    1 3\n    2 4\"]\n\n    Transpose --&gt; Reverse[\"Reverse Rows:\n    3 1\n    4 2\"]\n\n    Result[\"Result (Rotated 90):\n    3 1\n    4 2\"]\n\n    class Result matrix</code></pre>"},{"location":"microsoft/14_rotate_image/#solution","title":"Solution","text":"<pre><code>def rotate(self, matrix: list[list[int]]) -&gt; None:\n    n = len(matrix)\n    # 1. Transpose\n    for i in range(n):\n        for j in range(i, n):\n            matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n    # 2. Reverse\n    for i in range(n):\n        matrix[i].reverse()\n</code></pre>"},{"location":"microsoft/15_airplane_seat_prob/","title":"Airplane Seat Assignment Probability \ud83d\udfe1 Medium","text":"<p>Tags: <code>Math</code>, <code>Brainteaser</code>, <code>Probability</code></p>"},{"location":"microsoft/15_airplane_seat_prob/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Probability \ud83d\udd34 Hard Critical Inductive reasoning"},{"location":"microsoft/15_airplane_seat_prob/#the-challenge","title":"The Challenge","text":"<p><code>n</code> passengers board an airplane with exactly <code>n</code> seats. The first passenger has lost the ticket and picks a seat randomly. But after that, the rest of the passengers will: - Take their own seat if it is still available,  - Pick other seats randomly when they find their seat occupied.</p> <p>Return the probability that the <code>n</code>-th person gets his own seat.</p> <p>Constraints: - $1 \\leq n \\leq 10^5$</p> <p>Example: <pre><code>Input: n = 2\nOutput: 0.5\n</code></pre></p>"},{"location":"microsoft/15_airplane_seat_prob/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/15_airplane_seat_prob/#mathematical-induction","title":"Mathematical Induction","text":"<ol> <li>Passenger 1:<ul> <li>Picks seat 1 (Correct): Everyone else sits correct. Nth gets N. Success.</li> <li>Picks seat N (Incorrect): Nth seat taken. Failure.</li> <li>Picks seat K ($1 &lt; k &lt; N$): Passenger K is now displaced. Same problem reduced.</li> </ul> </li> <li>Symmetry:<ul> <li>At any point where a \"displaced\" person picks a seat, they are equally likely to pick Seat 1 (resolving the chain, everyone remaining is happy including N) or Seat N (dooming N).</li> <li>Therefore, P(Success) = P(Fail) = 0.5.</li> <li>Base case N=1: P=1.0.</li> </ul> </li> </ol>"},{"location":"microsoft/15_airplane_seat_prob/#strategic-analysis-real-world-context","title":"Strategic Analysis &amp; Real-World Context","text":"<p>[!NOTE] Why this matters: Interview favorite for testing intuition over brute force simulation.</p>"},{"location":"microsoft/15_airplane_seat_prob/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(1)$ Constant logic. Space $O(1)$ No storage."},{"location":"microsoft/15_airplane_seat_prob/#visual-walkthrough","title":"Visual Walkthrough","text":"<p><code>N=3</code></p> <pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef branch fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    P1[\"Person 1 enters\"] --&gt; Ch1{\"Pick?\"}\n    Ch1 --\"Pick Seat 1 (1/N)\"--&gt; Win[\"All subsequent sit correct. N gets N.\"]\n    Ch1 --\"Pick Seat N (1/N)\"--&gt; Loss[\"N's seat taken. N loses.\"]\n    Ch1 --\"Pick Seat K (Rest)\"--&gt; Defer[\"Person K becomes new 'Person 1'. Situation recursive.\"]\n\n    Defer --&gt; Logic[\"Symmetry: Eventually picks 1 or N with equal prob.\"]\n    Logic --&gt; Result[\"Probability = 0.5\"]\n\n    class Win branch</code></pre>"},{"location":"microsoft/15_airplane_seat_prob/#solution","title":"Solution","text":"<pre><code>def nth_person_gets_nth_seat(self, n: int) -&gt; float:\n    return 1.0 if n == 1 else 0.5\n</code></pre>"},{"location":"microsoft/m01_largest_rectangle_histogram/","title":"Largest Rectangle in Histogram \ud83d\udd34 Hard","text":"<p>Tags: <code>Stack</code>, <code>Array</code></p>"},{"location":"microsoft/m01_largest_rectangle_histogram/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Monotonic Stack \ud83d\udd34 Hard Critical Efficiently finding boundaries"},{"location":"microsoft/m01_largest_rectangle_histogram/#the-challenge","title":"The Challenge","text":"<p>Given an array of integers <code>heights</code> representing the histogram's bar height where the width of each bar is 1, return the area of the largest rectangle in the histogram.</p> <p>Constraints: - $1 \\leq heights.length \\leq 10^5$ - $0 \\leq heights[i] \\leq 10^4$</p> <p>Example: <pre><code>Input: heights = [2,1,5,6,2,3]\nOutput: 10\nExplanation: The bars 5 and 6 form a rectangle of height 5 and width 2.\n</code></pre></p>"},{"location":"microsoft/m01_largest_rectangle_histogram/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m01_largest_rectangle_histogram/#optimal-approach-monotonic-stack","title":"Optimal Approach (Monotonic Stack)","text":"<p>We use a stack to keep track of indices of bars in increasing order of height. - Logic: For each bar, if it's shorter than the bar at the stack top, we've found the right boundary for the bar at the top. The left boundary is the index below it in the stack. - Complexity: Each index is pushed and popped once.</p>"},{"location":"microsoft/m01_largest_rectangle_histogram/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass with stack operations. Space $O(N)$ Stack depth."},{"location":"microsoft/m01_largest_rectangle_histogram/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Start([\"heights: [2, 1, 5, 6, 2, 3]\"]) --&gt; Push2[\"Push 2 (idx 0)\"]\n    Push2 --&gt; Pop2[\"1 &lt; 2: Pop 2. Area = 2*1 = 2\"]\n    Pop2 --&gt; Push1[\"Push 1 (idx 1)\"]\n    Push1 --&gt; Push5[\"Push 5 (idx 2)\"]\n    Push5 --&gt; Push6[\"Push 6 (idx 3)\"]\n    Push6 --&gt; Pop6[\"2 &lt; 6: Pop 6. Area = 6*1 = 6\"]\n    Pop6 --&gt; Pop5[\"2 &lt; 5: Pop 5. Area = 5*2 = 10\"]</code></pre>"},{"location":"microsoft/m01_largest_rectangle_histogram/#solution","title":"Solution","text":"<pre><code>def largest_rectangle_area(self, heights: list[int]) -&gt; int:\n    stack = [-1]\n    max_area = 0\n    for i, h in enumerate(heights):\n        while stack[-1] != -1 and heights[stack[-1]] &gt;= h:\n            curr_h = heights[stack.pop()]\n            curr_w = i - stack[-1] - 1\n            max_area = max(max_area, curr_h * curr_w)\n        stack.append(i)\n    while stack[-1] != -1:\n        curr_h = heights[stack.pop()]\n        curr_w = len(heights) - stack[-1] - 1\n        max_area = max(max_area, curr_h * curr_w)\n    return max_area\n</code></pre>"},{"location":"microsoft/m02_linked_list_cycle/","title":"Linked List Cycle \ud83d\udfe2 Easy","text":"<p>Tags: <code>Linked List</code>, <code>Two Pointers</code></p>"},{"location":"microsoft/m02_linked_list_cycle/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Two Pointers \ud83d\udfe2 Easy Critical Floyd's Cycle-Finding Algorithm"},{"location":"microsoft/m02_linked_list_cycle/#the-challenge","title":"The Challenge","text":"<p>Given <code>head</code>, the head of a linked list, determine if the linked list has a cycle in it.</p> <p>Constraints: - The number of nodes in the list is in the range $[0, 10^4]$. - $-10^5 \\leq Node.val \\leq 10^5$</p> <p>Example: <pre><code>Input: head = [3,2,0,-4], pos = 1 (cycle)\nOutput: True\n</code></pre></p>"},{"location":"microsoft/m02_linked_list_cycle/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m02_linked_list_cycle/#optimal-approach-floyds-tortoise-and-hare","title":"Optimal Approach (Floyd's Tortoise and Hare)","text":"<p>Use two pointers, <code>slow</code> and <code>fast</code>. - <code>slow</code> moves 1 step. - <code>fast</code> moves 2 steps. - If they meet, there is a cycle. If <code>fast</code> reaches <code>None</code>, there isn't.</p>"},{"location":"microsoft/m02_linked_list_cycle/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Fast pointer traverses at most 2N nodes. Space $O(1)$ Constant extra space."},{"location":"microsoft/m02_linked_list_cycle/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    A((3)) --&gt; B((2))\n    B --&gt; C((0))\n    C --&gt; D((-4))\n    D --&gt; B\n\n    S[\"Slow\"] -.-&gt; B\n    F[\"Fast\"] -.-&gt; C</code></pre>"},{"location":"microsoft/m02_linked_list_cycle/#solution","title":"Solution","text":"<pre><code>def has_cycle(self, head: ListNode | None) -&gt; bool:\n    slow = fast = head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n</code></pre>"},{"location":"microsoft/m03_group_anagrams/","title":"Group Anagrams \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Hash Map</code>, <code>String</code></p>"},{"location":"microsoft/m03_group_anagrams/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Hash Maps \ud83d\udfe2 Easy Critical Tracking groups Sorting \ud83d\udfe2 Easy High Generating unique keys"},{"location":"microsoft/m03_group_anagrams/#the-challenge","title":"The Challenge","text":"<p>Given an array of strings <code>strs</code>, group the anagrams together. You can return the answer in any order.</p> <p>Constraints: - $1 \\leq strs.length \\leq 10^4$ - $0 \\leq strs[i].length \\leq 100$</p> <p>Example: <pre><code>Input: strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]\nOutput: [[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]]\n</code></pre></p>"},{"location":"microsoft/m03_group_anagrams/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m03_group_anagrams/#optimal-approach-sorting-as-key","title":"Optimal Approach (Sorting as Key)","text":"<p>Iterate through the strings. For each string: 1. Sort its characters to create a unique key (e.g., \"eat\" -&gt; \"aet\"). 2. Store the original string in a hash map under this key.</p>"},{"location":"microsoft/m03_group_anagrams/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\cdot K \\log K)$ Sorting $N$ strings of length $K$. Space $O(N \\cdot K)$ Storage for result."},{"location":"microsoft/m03_group_anagrams/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Input[\"'eat', 'tea', 'tan'\"] --&gt; Sort[\"Sort: 'aet', 'aet', 'ant'\"]\n    Sort --&gt; Map[\"Map: {'aet': ['eat', 'tea'], 'ant': ['tan']}\"]\n    Map --&gt; Output[\"[['eat', 'tea'], ['tan']]\"]\n    class Output primary</code></pre>"},{"location":"microsoft/m03_group_anagrams/#solution","title":"Solution","text":"<pre><code>def group_anagrams(self, strs: list[str]) -&gt; list[list[str]]:\n    groups = {}\n    for s in strs:\n        key = \"\".join(sorted(s))\n        groups.setdefault(key, []).append(s)\n    return list(groups.values())\n</code></pre>"},{"location":"microsoft/m04_letter_combinations/","title":"Letter Combinations of a Phone Number \ud83d\udfe1 Medium","text":"<p>Tags: <code>Backtracking</code>, <code>Hash Map</code>, <code>String</code></p>"},{"location":"microsoft/m04_letter_combinations/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Recursion (Backtracking) \ud83d\udfe1 Medium Critical Exploring all combinations"},{"location":"microsoft/m04_letter_combinations/#the-challenge","title":"The Challenge","text":"<p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p> <p>Constraints: - $0 \\leq digits.length \\leq 4$ - <code>digits[i]</code> is a digit in the range ['2', '9'].</p> <p>Example: <pre><code>Input: digits = \"23\"\nOutput: [\"ad\",\"ae\",\"af\",\"bd\",\"be\",\"bf\",\"cd\",\"ce\",\"cf\"]\n</code></pre></p>"},{"location":"microsoft/m04_letter_combinations/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m04_letter_combinations/#optimal-approach-backtracking","title":"Optimal Approach (Backtracking)","text":"<p>Use a map to relate digits to letters. Use recursion to build combinations. - Base Case: If current combination length == digits length, add to results. - Recursive Step: Pick a letter for the current digit, then recurse for the next digit.</p>"},{"location":"microsoft/m04_letter_combinations/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(4^N)$ $N$ is number of digits. Max 4 letters per digit. Space $O(N)$ Recursion depth."},{"location":"microsoft/m04_letter_combinations/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Root[\"''\"] --&gt; A[\"'a' (2)\"]\n    Root --&gt; B[\"'b' (2)\"]\n    A --&gt; AD[\"'ad' (3)\"]\n    A --&gt; AE[\"'ae' (3)\"]\n    B --&gt; BD[\"'bd' (3)\"]\n    class AD,AE,BD primary</code></pre>"},{"location":"microsoft/m04_letter_combinations/#solution","title":"Solution","text":"<pre><code>def letter_combinations(self, digits: str) -&gt; list[str]:\n    if not digits: return []\n    digit_map = {\"2\":\"abc\",\"3\":\"def\",\"4\":\"ghi\",\"5\":\"jkl\",\"6\":\"mno\",\"7\":\"pqrs\",\"8\":\"tuv\",\"9\":\"wxyz\"}\n    res = []\n    def backtrack(index, path):\n        if index == len(digits):\n            res.append(\"\".join(path))\n            return\n        for char in digit_map[digits[index]]:\n            path.append(char)\n            backtrack(index+1, path)\n            path.pop()\n    backtrack(0, [])\n    return res\n</code></pre>"},{"location":"microsoft/m05_valid_sudoku/","title":"Valid Sudoku \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Hash Table</code>, <code>Matrix</code></p>"},{"location":"microsoft/m05_valid_sudoku/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Hash Sets \ud83d\udfe2 Easy Critical Duplicate detection"},{"location":"microsoft/m05_valid_sudoku/#the-challenge","title":"The Challenge","text":"<p>Determine if a 9x9 Sudoku board is valid. Only the filled cells need to be validated.</p> <p>Example: <pre><code>Input:\n[[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"]\n,[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"]\n,...]\nOutput: True\n</code></pre></p>"},{"location":"microsoft/m05_valid_sudoku/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m05_valid_sudoku/#optimal-approach-one-pass-with-sets","title":"Optimal Approach (One Pass with Sets)","text":"<p>Use 3 lists of 9 sets each to track digits seen in each row, column, and 3x3 box. - Logic: For each cell <code>(r, c)</code> with digit <code>v</code>, check if <code>v</code> exists in <code>row[r]</code>, <code>col[c]</code>, or <code>box[idx]</code>. - Box Index: <code>(r // 3) * 3 + (c // 3)</code>.</p>"},{"location":"microsoft/m05_valid_sudoku/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(1)$ Board size is fixed at 9x9. Space $O(1)$ Fixed storage required."},{"location":"microsoft/m05_valid_sudoku/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Cell[\"Board[0][0] = '5'\"] --&gt; Check{\"'5' in Row 0, Col 0, or Box 0?\"}\n    Check -- No --&gt; Store[\"Add '5' to Row 0, Col 0, Box 0\"]\n    Store --&gt; Next[\"Next Cell...\"]</code></pre>"},{"location":"microsoft/m05_valid_sudoku/#solution","title":"Solution","text":"<pre><code>def is_valid_sudoku(self, board: list[list[str]]) -&gt; bool:\n    rows = [set() for _ in range(9)]; cols = [set() for _ in range(9)]; boxes = [set() for _ in range(9)]\n    for r in range(9):\n        for c in range(9):\n            val = board[r][c]\n            if val == \".\": continue\n            idx = (r // 3) * 3 + (c // 3)\n            if val in rows[r] or val in cols[c] or val in boxes[idx]: return False\n            rows[r].add(val); cols[c].add(val); boxes[idx].add(val)\n    return True\n</code></pre>"},{"location":"microsoft/m06_word_search/","title":"Word Search \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Backtracking</code>, <code>Matrix</code></p>"},{"location":"microsoft/m06_word_search/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Depth First Search (DFS) \ud83d\udfe1 Medium Critical Exploring grid paths"},{"location":"microsoft/m06_word_search/#the-challenge","title":"The Challenge","text":"<p>Given an <code>m x n</code> grid of characters <code>board</code> and a string <code>word</code>, return <code>true</code> if <code>word</code> exists in the grid.</p> <p>Constraints: - $1 \\leq m, n \\leq 6$ - $1 \\leq word.length \\leq 15$</p>"},{"location":"microsoft/m06_word_search/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m06_word_search/#optimal-approach-backtrackingdfs","title":"Optimal Approach (Backtracking/DFS)","text":"<p>Iterate through every cell. If the cell matches the first letter of <code>word</code>, start a DFS. - Logic: Move in 4 directions. Mark current cell as visited (e.g., using <code>#</code>) to avoid re-using it in the same path. Backtrack by restoring the character after recursion.</p>"},{"location":"microsoft/m06_word_search/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\cdot M \\cdot 4^L)$ $L$ is word length. Space $O(L)$ Recursion depth."},{"location":"microsoft/m06_word_search/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Start[\"Find 'A' in grid\"] --&gt; Match[\"Found at (0,0). DFS for 'B'\"]\n    Match --&gt; Dir[\"Check Right, Down...\"]\n    Dir --&gt; Found[\"Found 'B' at (0,1). DFS for 'C'\"]\n    class Found primary</code></pre>"},{"location":"microsoft/m06_word_search/#solution","title":"Solution","text":"<pre><code>def word_search(self, board: list[list[str]], word: str) -&gt; bool:\n    rows, cols = len(board), len(board[0])\n    def dfs(r, c, k):\n        if k == len(word): return True\n        if r&lt;0 or r&gt;=rows or c&lt;0 or c&gt;=cols or board[r][c]!=word[k]: return False\n        temp = board[r][c]; board[r][c] = \"#\"\n        res = dfs(r+1,c,k+1) or dfs(r-1,c,k+1) or dfs(r,c+1,k+1) or dfs(r,c-1,k+1)\n        board[r][c] = temp\n        return res\n    for r in range(rows):\n        for c in range(cols):\n            if dfs(r, c, 0): return True\n    return False\n</code></pre>"},{"location":"microsoft/m07_min_depth/","title":"Minimum Depth of Binary Tree \ud83d\udfe2 Easy","text":"<p>Tags: <code>Tree</code>, <code>DFS</code>, <code>BFS</code></p>"},{"location":"microsoft/m07_min_depth/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Tree Traversal \ud83d\udfe2 Easy Critical DFS/BFS foundations"},{"location":"microsoft/m07_min_depth/#the-challenge","title":"The Challenge","text":"<p>Find the minimum depth of a binary tree. The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p> <p>Constraints: - The number of nodes in the tree is in the range $[0, 10^5]$. - $-1000 \\leq Node.val \\leq 1000$</p>"},{"location":"microsoft/m07_min_depth/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m07_min_depth/#optimal-approach-dfs","title":"Optimal Approach (DFS)","text":"<p>Calculate the depth of left and right subtrees. - Edge Case: If one child is missing, the depth is determined by the other child (not zero, as a leaf must have no children). - Recurrence: <code>1 + min(depth(left), depth(right))</code> if both exist.</p>"},{"location":"microsoft/m07_min_depth/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Visit each node once. Space $O(H)$ $H$ is tree height (stack space)."},{"location":"microsoft/m07_min_depth/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Root((3)) --&gt; L((9))\n    Root --&gt; R((20))\n    R --&gt; RL((15))\n    R --&gt; RR((7))\n\n    L --- Leaf1[\"Leaf! Depth 2\"]\n    RL --- Leaf2[\"Leaf! Depth 3\"]\n    class Leaf1 primary</code></pre>"},{"location":"microsoft/m07_min_depth/#solution","title":"Solution","text":"<pre><code>def min_depth(self, root: TreeNode | None) -&gt; int:\n    if not root: return 0\n    if not root.left: return self.min_depth(root.right) + 1\n    if not root.right: return self.min_depth(root.left) + 1\n    return min(self.min_depth(root.left), self.min_depth(root.right)) + 1\n</code></pre>"},{"location":"microsoft/m08_rotate_array/","title":"Rotate Array \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Two Pointers</code></p>"},{"location":"microsoft/m08_rotate_array/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Array Manipulation \ud83d\udfe2 Easy Critical In-place modifications"},{"location":"microsoft/m08_rotate_array/#the-challenge","title":"The Challenge","text":"<p>Given an integer array <code>nums</code>, rotate the array to the right by <code>k</code> steps, where <code>k</code> is non-negative.</p> <p>Constraints: - $1 \\leq nums.length \\leq 10^5$ - $0 \\leq k \\leq 10^5$</p> <p>Example: <pre><code>Input: nums = [1,2,3,4,5,6,7], k = 3\nOutput: [5,6,7,1,2,3,4]\n</code></pre></p>"},{"location":"microsoft/m08_rotate_array/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m08_rotate_array/#optimal-approach-reversal-trick","title":"Optimal Approach (Reversal Trick)","text":"<ol> <li>Reverse the entire array.</li> <li>Reverse the first <code>k</code> elements.</li> <li>Reverse the remaining <code>n-k</code> elements.</li> <li>Why: Reversing twice restores order for sub-segments while shifting their positions.</li> </ol>"},{"location":"microsoft/m08_rotate_array/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Three passes over the array. Space $O(1)$ In-place rotation."},{"location":"microsoft/m08_rotate_array/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Start[\"[1,2,3,4,5], k=2\"] --&gt; RevAll[\"RevAll: [5,4,3,2,1]\"]\n    RevAll --&gt; RevK[\"Rev first 2: [4,5,3,2,1]\"]\n    RevK --&gt; RevRest[\"Rev last 3: [4,5,1,2,3]\"]\n    class RevRest primary</code></pre>"},{"location":"microsoft/m08_rotate_array/#solution","title":"Solution","text":"<pre><code>def rotate_array(self, nums: list[int], k: int) -&gt; None:\n    n = len(nums)\n    k %= n\n    def reverse(left, right):\n        while left &lt; right:\n            nums[left], nums[right] = nums[right], nums[left]\n            left, right = left + 1, right - 1\n    reverse(0, n - 1)\n    reverse(0, k - 1)\n    reverse(k, n - 1)\n</code></pre>"},{"location":"microsoft/m09_largest_palindrome/","title":"Largest Palindromic Substring \ud83d\udfe1 Medium","text":"<p>Tags: <code>String</code>, <code>Dynamic Programming</code></p>"},{"location":"microsoft/m09_largest_palindrome/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Palindrome Logic \ud83d\udfe2 Easy Critical Symmetry detection"},{"location":"microsoft/m09_largest_palindrome/#the-challenge","title":"The Challenge","text":"<p>Given a string <code>s</code>, return the longest palindromic substring in <code>s</code>.</p> <p>Constraints: - $1 \\leq s.length \\leq 1000$</p> <p>Example: <pre><code>Input: s = \"babad\"\nOutput: \"bab\" (or \"aba\")\n</code></pre></p>"},{"location":"microsoft/m09_largest_palindrome/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m09_largest_palindrome/#optimal-approach-expand-around-center","title":"Optimal Approach (Expand Around Center)","text":"<p>For each character (and each gap between characters), treat it as a potential center of a palindrome and expand outwards. - Logic: A palindrome of length $N$ has a palindrome of length $N-2$ inside it.</p>"},{"location":"microsoft/m09_largest_palindrome/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N^2)$ $N$ centers, each expanding up to $N/2$. Space $O(1)$ No extra space beyond result."},{"location":"microsoft/m09_largest_palindrome/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Center[\"Center 'b' at idx 2\"] --&gt; E1[\"Check 'a'=='a'? Yes.\"]\n    E1 --&gt; E2[\"Check 'b'=='d'? No.\"]\n    E2 --&gt; Res[\"Palindrome: 'aba'\"]\n    class Res primary</code></pre>"},{"location":"microsoft/m09_largest_palindrome/#solution","title":"Solution","text":"<pre><code>def longest_palindrome(self, s: str) -&gt; str:\n    if not s: return \"\"\n    def expand(left, right):\n        while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n            left -= 1; right += 1\n        return s[left+1 : right]\n    res = \"\"\n    for i in range(len(s)):\n        p1 = expand(i, i)\n        if len(p1) &gt; len(res): res = p1\n        p2 = expand(i, i + 1)\n        if len(p2) &gt; len(res): res = p2\n    return res\n</code></pre>"},{"location":"microsoft/m10_combination_sum/","title":"Combination Sum \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Backtracking</code></p>"},{"location":"microsoft/m10_combination_sum/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Recursion \ud83d\udfe1 Medium Critical Exploring combinations"},{"location":"microsoft/m10_combination_sum/#the-challenge","title":"The Challenge","text":"<p>Given an array of distinct integers <code>candidates</code> and a <code>target</code> integer, return a list of all unique combinations where the chosen numbers sum to <code>target</code>. You may use the same number an unlimited number of times.</p> <p>Constraints: - $1 \\leq candidates.length \\leq 30$ - $1 \\leq candidates[i] \\leq 200$ - $1 \\leq target \\leq 500$</p>"},{"location":"microsoft/m10_combination_sum/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m10_combination_sum/#optimal-approach-backtracking","title":"Optimal Approach (Backtracking)","text":"<p>Sort candidates to allow pruning. - Logic: In the recursion, maintain a <code>remain</code> target. For each choice, subtract it and recurse. To avoid duplicates, start the next search from the current index.</p>"},{"location":"microsoft/m10_combination_sum/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(2^T)$ $T$ is target; roughly exponential. Space $O(T/min)$ Recursion depth."},{"location":"microsoft/m10_combination_sum/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Root[\"Target 7\"] --&gt; C2[\"Pick 2 (Remain 5)\"]\n    C2 --&gt; C2_2[\"Pick 2 (Remain 3)\"]\n    C2_2 --&gt; C2_2_3[\"Pick 3 (Remain 0)\"]\n    C2_2_3 --&gt; Success[\"[2, 2, 3]!\"]\n    class Success primary</code></pre>"},{"location":"microsoft/m10_combination_sum/#solution","title":"Solution","text":"<pre><code>def combination_sum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n    results = []\n    def backtrack(remain, curr, start):\n        if remain == 0:\n            results.append(list(curr))\n            return\n        for i in range(start, len(candidates)):\n            if candidates[i] &lt;= remain:\n                curr.append(candidates[i])\n                backtrack(remain - candidates[i], curr, i)\n                curr.pop()\n    candidates.sort()\n    backtrack(target, [], 0)\n    return results\n</code></pre>"},{"location":"microsoft/m11_valid_palindrome/","title":"Valid Palindrome \ud83d\udfe2 Easy","text":"<p>Tags: <code>Two Pointers</code>, <code>String</code></p>"},{"location":"microsoft/m11_valid_palindrome/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Two Pointers \ud83d\udfe2 Easy Critical Comparing from boundaries"},{"location":"microsoft/m11_valid_palindrome/#the-challenge","title":"The Challenge","text":"<p>Given a string <code>s</code>, return <code>true</code> if it is a palindrome, or <code>false</code> otherwise, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters.</p> <p>Constraints: - $1 \\leq s.length \\leq 2 \\cdot 10^5$</p> <p>Example: <pre><code>Input: s = \"A man, a plan, a canal: Panama\"\nOutput: True\n</code></pre></p>"},{"location":"microsoft/m11_valid_palindrome/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m11_valid_palindrome/#optimal-approach-two-pointers","title":"Optimal Approach (Two Pointers)","text":"<p>Initialize pointers at <code>0</code> and <code>len(s)-1</code>. - Logic: Skip non-alphanumeric characters. Compare the characters at both pointers (case-insensitive). Move pointers inward.</p>"},{"location":"microsoft/m11_valid_palindrome/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass. Space $O(1)$ No extra space used."},{"location":"microsoft/m11_valid_palindrome/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Start[\"'A' ... 'a'\"] --&gt; Match1[\"'a' == 'a'? Yes.\"]\n    Match1 --&gt; Skip[\", skip\"]\n    Skip --&gt; Match2[\"'m' ... 'm'\"]\n    class Match2 primary</code></pre>"},{"location":"microsoft/m11_valid_palindrome/#solution","title":"Solution","text":"<pre><code>def is_valid_palindrome(self, s: str) -&gt; bool:\n    left, right = 0, len(s) - 1\n    while left &lt; right:\n        while left &lt; right and not s[left].isalnum(): left += 1\n        while left &lt; right and not s[right].isalnum(): right -= 1\n        if s[left].lower() != s[right].lower(): return False\n        left += 1; right -= 1\n    return True\n</code></pre>"},{"location":"microsoft/m12_delete_node/","title":"Delete Node in a Linked List \ud83d\udfe1 Medium","text":"<p>Tags: <code>Linked List</code></p>"},{"location":"microsoft/m12_delete_node/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Node Pointers \ud83d\udfe2 Easy Critical Basic list manipulation"},{"location":"microsoft/m12_delete_node/#the-challenge","title":"The Challenge","text":"<p>Delete a node from a singly linked list. You are given only access to the node to be deleted (not the head).</p> <p>Constraints: - The node to be deleted is in the list and is not a tail node.</p>"},{"location":"microsoft/m12_delete_node/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m12_delete_node/#optimal-approach-value-shifting","title":"Optimal Approach (Value Shifting)","text":"<p>Since we can't delete the node normally (we don't have the previous node), we copy the data from the next node into the current node, then \"delete\" the next node.</p>"},{"location":"microsoft/m12_delete_node/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(1)$ Single operation. Space $O(1)$ No extra space."},{"location":"microsoft/m12_delete_node/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    A((4)) --&gt; B((5))\n    B --&gt; C((1))\n    C --&gt; D((9))\n\n    B -- \"Copy val\" --&gt; Bv((1))\n    Bv -- \"Skip next\" --&gt; D</code></pre>"},{"location":"microsoft/m12_delete_node/#solution","title":"Solution","text":"<pre><code>def delete_node(self, node: ListNode) -&gt; None:\n    # Copy next node's value and skip it\n    node.val = node.next.val\n    node.next = node.next.next\n</code></pre>"},{"location":"microsoft/m13_buy_sell_stock/","title":"Best Time to Buy and Sell Stock \ud83d\udfe2 Easy","text":"<p>Tags: <code>Array</code>, <code>Dynamic Programming</code></p>"},{"location":"microsoft/m13_buy_sell_stock/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Greedy \ud83d\udfe2 Easy Critical Keeping track of min price"},{"location":"microsoft/m13_buy_sell_stock/#the-challenge","title":"The Challenge","text":"<p>You are given an array <code>prices</code> where <code>prices[i]</code> is the price of a given stock on the <code>i</code>-th day. You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.</p> <p>Constraints: - $1 \\leq prices.length \\leq 10^5$</p> <p>Example: <pre><code>Input: [7,1,5,3,6,4]\nOutput: 5\nExplanation: Buy on day 2 (price 1) and sell on day 5 (price 6).\n</code></pre></p>"},{"location":"microsoft/m13_buy_sell_stock/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m13_buy_sell_stock/#optimal-approach-one-pass","title":"Optimal Approach (One Pass)","text":"<p>Initialize <code>min_price</code> to infinity and <code>max_profit</code> to 0. - Logic: For each price, if it's lower than <code>min_price</code>, update <code>min_price</code>. Otherwise, calculate the potential profit (<code>price - min_price</code>) and update <code>max_profit</code> if it's higher.</p>"},{"location":"microsoft/m13_buy_sell_stock/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Single pass through the array. Space $O(1)$ Constant extra space."},{"location":"microsoft/m13_buy_sell_stock/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph LR\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Price1[\"7 (Min: 7)\"] --&gt; Price2[\"1 (Min: 1)\"]\n    Price2 --&gt; Price3[\"5 (Profit: 4)\"]\n    Price3 --&gt; Price4[\"3 (Profit: 2)\"]\n    Price4 --&gt; Price5[\"6 (Profit: 5)\"]\n    class Price5 primary</code></pre>"},{"location":"microsoft/m13_buy_sell_stock/#solution","title":"Solution","text":"<pre><code>def max_profit(self, prices: list[int]) -&gt; int:\n    min_price = float(\"inf\")\n    max_profit = 0\n    for price in prices:\n        if price &lt; min_price:\n            min_price = price\n        elif price - min_price &gt; max_profit:\n            max_profit = price - min_price\n    return max_profit\n</code></pre>"},{"location":"microsoft/m14_spiral_matrix/","title":"Spiral Matrix \ud83d\udfe1 Medium","text":"<p>Tags: <code>Array</code>, <code>Matrix</code>, <code>Simulation</code></p>"},{"location":"microsoft/m14_spiral_matrix/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Matrix Traversal \ud83d\udfe2 Easy Critical Managing 4 boundaries"},{"location":"microsoft/m14_spiral_matrix/#the-challenge","title":"The Challenge","text":"<p>Given an <code>m x n</code> matrix, return all elements of the matrix in spiral order.</p> <p>Constraints: - $m, n \\leq 10$</p> <p>Example: <pre><code>Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]\n</code></pre></p>"},{"location":"microsoft/m14_spiral_matrix/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m14_spiral_matrix/#optimal-approach-simulation-with-boundaries","title":"Optimal Approach (Simulation with Boundaries)","text":"<p>Maintain 4 boundaries: <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>. - Logic: Traverse Right along <code>top</code>, then increment <code>top</code>. Traverse Down along <code>right</code>, then decrement <code>right</code>. Traverse Left along <code>bottom</code>, then decrement <code>bottom</code>. Traverse Up along <code>left</code>, then increment <code>left</code>. - Condition: Continue as long as <code>len(result) &lt; rows * cols</code>.</p>"},{"location":"microsoft/m14_spiral_matrix/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N \\cdot M)$ Visit each cell once. Space $O(1)$ No extra space beyond result."},{"location":"microsoft/m14_spiral_matrix/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef primary fill:#0ea5e9,stroke:#38bdf8,stroke-width:2px,color:#0f172a\n\n    Start[\"Top-Left\"] -- Right --&gt; TR[\"Top-Right\"]\n    TR -- Down --&gt; BR[\"Bottom-Right\"]\n    BR -- Left --&gt; BL[\"Bottom-Left\"]\n    BL -- Up --&gt; Done[\"Inner Path...\"]</code></pre>"},{"location":"microsoft/m14_spiral_matrix/#solution","title":"Solution","text":"<pre><code>def spiral_order(self, matrix: list[list[int]]) -&gt; list[int]:\n    if not matrix: return []\n    res = []\n    rows, cols = len(matrix), len(matrix[0])\n    top, bottom, left, right = 0, rows-1, 0, cols-1\n    while len(res) &lt; rows * cols:\n        for i in range(left, right + 1): res.append(matrix[top][i])\n        top += 1\n        if top &gt; bottom: break\n        for i in range(top, bottom + 1): res.append(matrix[i][right])\n        right -= 1\n        if left &gt; right: break\n        for i in range(right, left - 1, -1): res.append(matrix[bottom][i])\n        bottom -= 1\n        if top &gt; bottom: break\n        for i in range(bottom, top - 1, -1): res.append(matrix[i][left])\n        left += 1\n    return res\n</code></pre>"},{"location":"microsoft/m15_right_side_view/","title":"Binary Tree Right Side View \ud83d\udfe1 Medium","text":"<p>Tags: <code>Tree</code>, <code>BFS</code>, <code>DFS</code></p>"},{"location":"microsoft/m15_right_side_view/#prerequisite-topics","title":"Prerequisite Topics","text":"Topic Difficulty Relevance Notes Level Order Traversal \ud83d\udfe1 Medium Critical Identifying last node per level"},{"location":"microsoft/m15_right_side_view/#the-challenge","title":"The Challenge","text":"<p>Given the <code>root</code> of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.</p> <p>Example: <pre><code>Input: root = [1,2,3,null,5,null,4]\nOutput: [1,3,4]\n</code></pre></p>"},{"location":"microsoft/m15_right_side_view/#algorithmic-analysis","title":"Algorithmic Analysis","text":""},{"location":"microsoft/m15_right_side_view/#optimal-approach-bfs-level-order","title":"Optimal Approach (BFS / Level Order)","text":"<p>Perform a level-order traversal (using a queue). - Key Insight: For each level, the last node processed in the queue is the one visible from the right side. - Process: At each level, note the size, iterate through nodes, and only add the last node's value to the result list.</p>"},{"location":"microsoft/m15_right_side_view/#complexity-analysis","title":"Complexity Analysis","text":"Dimension Complexity Justification Time $O(N)$ Visit each node once. Space $O(W)$ $W$ is the max width of the tree."},{"location":"microsoft/m15_right_side_view/#visual-walkthrough","title":"Visual Walkthrough","text":"<pre><code>%%{init: {'theme': 'dark'}}%%\ngraph TD\n    classDef success fill:#22c55e,stroke:#4ade80,stroke-width:2px,color:#0f172a\n\n    Root((1)) --&gt; L((2))\n    Root --&gt; R((3))\n    L --&gt; L2((5))\n    R --&gt; R2((4))\n\n    class Root,R,R2 success</code></pre>"},{"location":"microsoft/m15_right_side_view/#solution","title":"Solution","text":"<pre><code>def right_side_view(self, root: TreeNode | None) -&gt; list[int]:\n    if not root: return []\n    result = []\n    queue = deque([root])\n    while queue:\n        level_size = len(queue)\n        for i in range(level_size):\n            node = queue.popleft()\n            if i == level_size - 1: result.append(node.val)\n            if node.left: queue.append(node.left)\n            if node.right: queue.append(node.right)\n    return result\n</code></pre>"},{"location":"source_code/amazon/","title":"Amazon Source Code","text":"<pre><code>import heapq\nfrom collections import Counter, deque\n\nfrom src.data_structures import ListNode, TreeNode\n\n\nclass AmazonSolutions:\n    \"\"\"\n    Solutions for Amazon DSA problems.\n    \"\"\"\n\n    def min_distance(self, word1: str, word2: str) -&gt; int:\n        \"\"\"\n        Calculates the Levenshtein Distance (Edit Distance) between two words.\n\n        Args:\n            word1: First string.\n            word2: Second string.\n\n        Returns:\n            The minimum number of operations (insert, delete, replace) to convert word1 to word2.\n        \"\"\"\n        m, n = len(word1), len(word2)\n        # DP table initialization\n        # dp[i][j] represents min operations to convert word1[:i] to word2[:j]\n        dp = [[0] * (n + 1) for _ in range(m + 1)]\n\n        # Base cases: converting empty string to non-empty requires insertions\n        for i in range(m + 1):\n            dp[i][0] = i\n        for j in range(n + 1):\n            dp[0][j] = j\n\n        for i in range(1, m + 1):\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    # If chars match, no new operation needed\n                    dp[i][j] = dp[i - 1][j - 1]\n                else:\n                    # If mismatch, take min of:\n                    # 1. Insert (dp[i][j-1])\n                    # 2. Delete (dp[i-1][j])\n                    # 3. Replace (dp[i-1][j-1])\n                    dp[i][j] = 1 + min(dp[i][j - 1], dp[i - 1][j], dp[i - 1][j - 1])\n\n        return dp[m][n]\n\n    def reverse_list(self, head: ListNode | None) -&gt; ListNode | None:\n        \"\"\"\n        Reverses a singly linked list.\n\n        Args:\n            head: Head of the list.\n\n        Returns:\n            New head of the reversed list.\n        \"\"\"\n        prev = None\n        curr = head\n        while curr:\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n        return prev\n\n    def trap(self, height: list[int]) -&gt; int:\n        \"\"\"\n        Computes how much water can be trapped after raining.\n\n        Args:\n            height: Elevation map (array of non-negative integers).\n\n        Returns:\n            Total amount of trapped water.\n        \"\"\"\n        if not height:\n            return 0\n        left, right = 0, len(height) - 1\n        left_max, right_max = height[left], height[right]\n        water = 0\n\n        while left &lt; right:\n            if left_max &lt; right_max:\n                left += 1\n                left_max = max(left_max, height[left])\n                water += left_max - height[left]\n            else:\n                right -= 1\n                right_max = max(right_max, height[right])\n                water += right_max - height[right]\n\n        return water\n\n    def merge_k_lists(self, lists: list[ListNode | None]) -&gt; ListNode | None:\n        \"\"\"\n        Merges k sorted linked lists into one sorted linked list.\n\n        Args:\n            lists: List of k sorted linked lists.\n\n        Returns:\n            Head of the merged sorted list.\n        \"\"\"\n        heap = []\n\n        # Initialize heap with the head of each list\n        # We store (val, idx, node) tuple. 'idx' acts as tie-breaker for same values\n        # so we don't compare nodes directly (which would fail if not supporting &lt;).\n        for i, node in enumerate(lists):\n            if node:\n                heapq.heappush(heap, (node.val, i, node))\n\n        dummy = ListNode()\n        curr = dummy\n\n        while heap:\n            val, i, node = heapq.heappop(heap)\n            curr.next = node\n            curr = curr.next\n\n            if node.next:\n                heapq.heappush(heap, (node.next.val, i, node.next))\n\n        return dummy.next\n\n    def is_valid(self, s: str) -&gt; bool:\n        \"\"\"\n        Validates parentheses.\n        \"\"\"\n        stack = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n        for char in s:\n            if char in mapping:\n                top = stack.pop() if stack else \"#\"\n                if mapping[char] != top:\n                    return False\n            else:\n                stack.append(char)\n        return not stack\n\n    def top_k_frequent(self, nums: list[int], k: int) -&gt; list[int]:\n        \"\"\"\n        Returns the k most frequent elements.\n        \"\"\"\n        # O(N) count\n        count = Counter(nums)\n        # O(N log K) heap\n        return heapq.nlargest(k, count.keys(), key=count.get)\n\n    def zigzag_level_order(self, root: TreeNode | None) -&gt; list[list[int]]:\n        \"\"\"\n        Returns the zigzag level order traversal of a binary tree.\n        \"\"\"\n        if not root:\n            return []\n\n        results = []\n        queue = deque([root])\n        left_to_right = True\n\n        while queue:\n            level_size = len(queue)\n            current_level = deque()\n\n            for _ in range(level_size):\n                node = queue.popleft()\n\n                if left_to_right:\n                    current_level.append(node.val)\n                else:\n                    current_level.appendleft(node.val)\n\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            results.append(list(current_level))\n            left_to_right = not left_to_right\n\n        return results\n\n    def find_median_sorted_arrays(self, nums1: list[int], nums2: list[int]) -&gt; float:\n        \"\"\"\n        Finds the median of two sorted arrays.\n        \"\"\"\n        # Ensure nums1 is the smaller array to minimize binary search range\n        if len(nums1) &gt; len(nums2):\n            nums1, nums2 = nums2, nums1\n\n        m, n = len(nums1), len(nums2)\n        start, end = 0, m\n\n        while start &lt;= end:\n            partition1 = (start + end) // 2\n            partition2 = (m + n + 1) // 2 - partition1\n\n            # If partition1 is 0 it means nothing is there on left side. Use -INF.\n            # If partition1 is m it means nothing is there on right side. Use +INF.\n            max_left1 = float(\"-inf\") if partition1 == 0 else nums1[partition1 - 1]\n            min_right1 = float(\"inf\") if partition1 == m else nums1[partition1]\n\n            max_left2 = float(\"-inf\") if partition2 == 0 else nums2[partition2 - 1]\n            min_right2 = float(\"inf\") if partition2 == n else nums2[partition2]\n\n            if max_left1 &lt;= min_right2 and max_left2 &lt;= min_right1:\n                # We have partitioned array at correct place\n                if (m + n) % 2 == 0:\n                    return (max(max_left1, max_left2) + min(min_right1, min_right2)) / 2.0\n                else:\n                    return max(max_left1, max_left2)\n            elif max_left1 &gt; min_right2:\n                # We are too far on right side for partition1. Go on left side.\n                end = partition1 - 1\n            else:\n                # We are too far on left side for partition1. Go on right side.\n                start = partition1 + 1\n\n        raise ValueError(\"Input arrays are not sorted\")\n\n    def is_subtree(self, root: TreeNode | None, sub_root: TreeNode | None) -&gt; bool:\n        \"\"\"\n        Determines if sub_root is a subtree of root.\n        \"\"\"\n        if not root:\n            return False\n        if self._is_same_tree(root, sub_root):\n            return True\n        return self.is_subtree(root.left, sub_root) or self.is_subtree(root.right, sub_root)\n\n    def _is_same_tree(self, p: TreeNode | None, q: TreeNode | None) -&gt; bool:\n        if not p and not q:\n            return True\n        if not p or not q or p.val != q.val:\n            return False\n        return self._is_same_tree(p.left, q.left) and self._is_same_tree(p.right, q.right)\n\n    def is_palindrome(self, head: ListNode | None) -&gt; bool:\n        \"\"\"\n        Checks if a linked list is a palindrome.\n        \"\"\"\n        # Edge case: empty or single node\n        if not head or not head.next:\n            return True\n\n        # 1. Find middle\n        slow, fast = head, head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n\n        # 2. Reverse second half\n        prev = None\n        curr = slow\n        while curr:\n            temp = curr.next\n            curr.next = prev\n            prev = curr\n            curr = temp\n\n        # 3. Compare halves\n        left, right = head, prev\n        while right:  # Only check right half length\n            if left.val != right.val:\n                return False\n            left = left.next\n            right = right.next\n        return True\n\n    def reorder_log_files(self, logs: list[str]) -&gt; list[str]:\n        \"\"\"\n        Reorders logs: Letter logs sorted by content then id. Digit logs maintain order.\n        \"\"\"\n        letter_logs = []\n        digit_logs = []\n\n        for log in logs:\n            # \"id content...\"\n            # split(maxsplit=1) -&gt; [id, content]\n            id_, content = log.split(\" \", 1)\n            if content[0].isalpha():\n                letter_logs.append((content, id_, log))\n            else:\n                digit_logs.append(log)\n\n        # Sort letter logs by content, then id\n        letter_logs.sort(key=lambda x: (x[0], x[1]))\n\n        return [x[2] for x in letter_logs] + digit_logs\n\n    def find_words(self, board: list[list[str]], words: list[str]) -&gt; list[str]:\n        \"\"\"\n        Word Search II: Finds all words from dictionary in 2D board.\n        \"\"\"\n        word_key = \"$\"\n        trie = {}\n        for word in words:\n            node = trie\n            for letter in word:\n                node = node.setdefault(letter, {})\n            node[word_key] = word\n\n        row_num, col_num = len(board), len(board[0])\n        matched_words = []\n\n        def backtracking(row, col, parent):\n            letter = board[row][col]\n            curr_node = parent[letter]\n\n            # Check for match\n            if word_key in curr_node:\n                matched_words.append(curr_node[word_key])\n                del curr_node[word_key]  # Prevent duplicate adds\n\n            board[row][col] = \"#\"  # mark visited\n\n            for r_offset, c_offset in [(0, 1), (0, -1), (1, 0), (-1, 0)]:\n                new_r, new_c = row + r_offset, col + c_offset\n                if (\n                    0 &lt;= new_r &lt; row_num\n                    and 0 &lt;= new_c &lt; col_num\n                    and board[new_r][new_c] in curr_node\n                ):\n                    backtracking(new_r, new_c, curr_node)\n\n            board[row][col] = letter  # backtrack\n\n            # Optimization: Prune empty nodes\n            if not curr_node:\n                del parent[letter]\n\n        for r in range(row_num):\n            for c in range(col_num):\n                if board[r][c] in trie:\n                    backtracking(r, c, trie)\n\n        return matched_words\n\n    def word_break(self, s: str, word_dict: list[str]) -&gt; bool:\n        \"\"\"\n        Determines if s can be segmented into a space-separated sequence of\n        one or more dictionary words.\n        \"\"\"\n        word_set = set(word_dict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n\n        for i in range(1, len(s) + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[len(s)]\n\n    def int_to_roman(self, num: int) -&gt; str:\n        \"\"\"\n        Converts an integer to a roman numeral.\n        \"\"\"\n        val_map = [\n            (1000, \"M\"),\n            (900, \"CM\"),\n            (500, \"D\"),\n            (400, \"CD\"),\n            (100, \"C\"),\n            (90, \"XC\"),\n            (50, \"L\"),\n            (40, \"XL\"),\n            (10, \"X\"),\n            (9, \"IX\"),\n            (5, \"V\"),\n            (4, \"IV\"),\n            (1, \"I\"),\n        ]\n        roman = []\n        for val, symbol in val_map:\n            while num &gt;= val:\n                roman.append(symbol)\n                num -= val\n        return \"\".join(roman)\n\n    def is_substring(self, s: str, t: str) -&gt; int:\n        \"\"\"\n        Checks if t is a substring of s (str.find() implementation).\n        \"\"\"\n        if not t:\n            return 0\n        n, m = len(s), len(t)\n        for i in range(n - m + 1):\n            if s[i : i + m] == t:\n                return i\n        return -1\n\n\nclass LRUCache:\n    \"\"\"\n    LRU Cache implementation using Hash Map + Doubly Linked List.\n    \"\"\"\n\n    class Node:\n        def __init__(self, key, val):\n            self.key = key\n            self.val = val\n            self.prev = None\n            self.next = None\n\n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = {}  # map key -&gt; node\n        # dummy head and tail\n        self.head = self.Node(0, 0)\n        self.tail = self.Node(0, 0)\n        self.head.next = self.tail\n        self.tail.prev = self.head\n\n    def _remove(self, node):\n        prev_node = node.prev\n        next_node = node.next\n        prev_node.next = next_node\n        next_node.prev = prev_node\n\n    def _add(self, node):\n        prev_node = self.tail.prev\n        prev_node.next = node\n        node.prev = prev_node\n        node.next = self.tail\n        self.tail.prev = node\n\n    def get(self, key: int) -&gt; int:\n        if key in self.cache:\n            node = self.cache[key]\n            self._remove(node)\n            self._add(node)\n            return node.val\n        return -1\n\n    def put(self, key: int, value: int) -&gt; None:\n        if key in self.cache:\n            self._remove(self.cache[key])\n        node = self.Node(key, value)\n        self._add(node)\n        self.cache[key] = node\n\n        if len(self.cache) &gt; self.capacity:\n            lru = self.head.next\n            self._remove(lru)\n            del self.cache[lru.key]\n\n\nclass MedianFinder:\n    \"\"\"\n    MedianFinder class to find the median from a data stream.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the MedianFinder object.\n        \"\"\"\n        # Max-heap to store the smaller half of the numbers\n        # We invert values to simulate max-heap with Python's min-heap\n        self.small = []\n        # Min-heap to store the larger half of the numbers\n        self.large = []\n\n    def add_num(self, num: int) -&gt; None:\n        \"\"\"\n        Adds the integer num from the data stream to the data structure.\n        \"\"\"\n        # Allow small heap to grow first\n        heapq.heappush(self.small, -num)\n\n        # Ensure every element in small is &lt;= every element in large\n        if self.small and self.large and (-self.small[0] &gt; self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # Balance sizes: small can have at most 1 more element than large\n        if len(self.small) &gt; len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) &gt; len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def find_median(self) -&gt; float:\n        \"\"\"\n        Returns the median of all elements so far.\n        \"\"\"\n        if len(self.small) &gt; len(self.large):\n            return float(-self.small[0])\n        return (-self.small[0] + self.large[0]) / 2.0\n\n\nclass MinStack:\n    \"\"\"\n    MinStack class to support push, pop, top, and retrieving the minimum element in constant time.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the stack.\n        \"\"\"\n        # Primary stack stores all elements\n        self.stack = []\n        # Min stack stores the minimum value at each state\n        self.min_stack = []\n\n    def push(self, val: int) -&gt; None:\n        \"\"\"\n        Pushes element val onto stack.\n        \"\"\"\n        self.stack.append(val)\n        # Update min_stack: push the current minimum\n        if not self.min_stack or val &lt;= self.min_stack[-1]:\n            self.min_stack.append(val)\n\n    def pop(self) -&gt; None:\n        \"\"\"\n        Removes the element on the top of the stack.\n        \"\"\"\n        if not self.stack:\n            return\n        val = self.stack.pop()\n        # If the popped value is the current minimum, pop from min_stack too\n        if val == self.min_stack[-1]:\n            self.min_stack.pop()\n\n    def top(self) -&gt; int:\n        \"\"\"\n        Gets the top element of the stack.\n        \"\"\"\n        return self.stack[-1]\n\n    def get_min(self) -&gt; int:\n        \"\"\"\n        Retrieves the minimum element in the stack.\n        \"\"\"\n        return self.min_stack[-1]\n</code></pre>"},{"location":"source_code/google/","title":"Google Source Code","text":"<pre><code>import heapq\nfrom collections import deque\n\nfrom src.data_structures import ListNode, TreeNode\n\n\nclass GoogleSolutions:\n    \"\"\"\n    Solutions for Google DSA problems.\n\n    Each method corresponds to a specific interview problem, implemented with\n    educational comments and optimal complexity.\n    \"\"\"\n\n    def two_sum(self, nums: list[int], target: int) -&gt; list[int]:\n        \"\"\"\n        Finds indices of two numbers in `nums` that add up to `target`.\n\n        Args:\n            nums: List of integers (input array).\n            target: The integer value to reach by summing two elements.\n\n        Returns:\n            A list containing the two indices [i, j] such that nums[i] + nums[j] == target.\n            Returns empty list if no solution found (though problem guarantees one).\n        \"\"\"\n        # Dictionary to store mapping: value -&gt; index\n        # This allows O(1) lookups to check if the complement exists.\n        seen: dict[int, int] = {}\n\n        # O(N) Loop: Iterate through the array once\n        for i, num in enumerate(nums):\n            # Calculate the number needed to reach the target\n            complement = target - num\n\n            # Check if the complement is already in our hash map\n            if complement in seen:\n                # Found the pair! Return current index and the complement's stored index\n                return [seen[complement], i]\n\n            # Store the current number and its index for future checks\n            seen[num] = i\n\n        # If no solution is found (logic shouldn't reach here per constraints)\n        return []\n\n    def level_order(self, root: \"TreeNode | None\") -&gt; list[list[int]]:\n        \"\"\"\n        Returns the level order traversal of a binary tree's nodes.\n\n        Args:\n            root: The root node of the binary tree.\n\n        Returns:\n            A list of lists, where each inner list contains the values of nodes\n            at that level, from left to right.\n        \"\"\"\n        # Handle edge case: empty tree\n        if not root:\n            return []\n\n        results: list[list[int]] = []\n        # Queue for BFS: stores nodes to visit (FIFO)\n        # Initialize with root\n        queue: deque[TreeNode] = deque([root])\n\n        while queue:\n            level_values: list[int] = []\n            # Calculate number of nodes at the current level\n            # This is critical: we must process exactly this many nodes\n            # to keep levels separate in the output.\n            level_size = len(queue)\n\n            for _ in range(level_size):\n                # Pop from left (FIFO)\n                node = queue.popleft()\n                level_values.append(node.val)\n\n                # Add children to queue for next level processing\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n\n            # Add the current level's values to the result\n            results.append(level_values)\n\n        return results\n\n    def length_of_longest_substring(self, s: str) -&gt; int:\n        \"\"\"\n        Finds the length of the longest substring without repeating characters.\n\n        Args:\n            s: The input string.\n\n        Returns:\n            The length of the longest substring containing unique characters.\n        \"\"\"\n        # Dictionary to store the last seen index of each character\n        char_index_map: dict[str, int] = {}\n        max_length = 0\n        left = 0  # Left boundary of the sliding window\n\n        for right, char in enumerate(s):\n            # If the character is already in the window, move the left pointer\n            # We move it to the right of the last occurrence to exclude the duplicate\n            if char in char_index_map and char_index_map[char] &gt;= left:\n                left = char_index_map[char] + 1\n\n            # Update the last seen index of the character\n            char_index_map[char] = right\n\n            # Update the maximum length found so far\n            # Window size is (right - left + 1)\n            max_length = max(max_length, right - left + 1)\n\n        return max_length\n\n    def find_kth_largest(self, nums: list[int], k: int) -&gt; int:\n        \"\"\"\n        Finds the kth largest element in an array.\n\n        Args:\n            nums: List of integers.\n            k: The rank of the largest element to find.\n\n        Returns:\n            The kth largest element.\n        \"\"\"\n        # Min-Heap Approach\n        # We maintain a min-heap of size k.\n        # The heap will store the k largest elements seen so far.\n        # The root of the heap (smallest element in the heap) will be the kth largest.\n\n        heap: list[int] = []\n\n        for num in nums:\n            # Push current number to heap\n            heapq.heappush(heap, num)\n\n            # If heap size exceeds k, remove the smallest element\n            # This ensures only the k largest elements remain\n            if len(heap) &gt; k:\n                heapq.heappop(heap)\n\n        # The top of the min-heap is the smallest of the k largest elements,\n        # which is exactly the kth largest element.\n        return heap[0]\n\n    def merge(self, intervals: list[list[int]]) -&gt; list[list[int]]:\n        \"\"\"\n        Merges all overlapping intervals.\n\n        Args:\n            intervals: A list of intervals where each interval is [start, end].\n\n        Returns:\n            A list of non-overlapping intervals that cover all the input intervals.\n        \"\"\"\n        # Edge case: empty list\n        if not intervals:\n            return []\n\n        # Sort intervals by their start time.\n        # This is critical: it allows us to merge in a single linear pass.\n        # Time Complexity of sort: O(N log N)\n        intervals.sort(key=lambda x: x[0])\n\n        merged: list[list[int]] = []\n\n        for interval in intervals:\n            # If the list of merged intervals is empty\n            # or if the current interval does not overlap with the previous one,\n            # simply append it.\n            if not merged or merged[-1][1] &lt; interval[0]:\n                merged.append(interval)\n            else:\n                # Otherwise, there is an overlap, so we merge the current and previous\n                # intervals. We do this by updating the end of the previous interval\n                # if the current interval ends later.\n                merged[-1][1] = max(merged[-1][1], interval[1])\n\n        return merged\n\n    def search(self, nums: list[int], target: int) -&gt; int:\n        \"\"\"\n        Searches for a target value in a rotated sorted array.\n\n        Args:\n            nums: The rotated sorted array.\n            target: The value to search for.\n\n        Returns:\n            The index of the target if found, otherwise -1.\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        while left &lt;= right:\n            mid = (left + right) // 2\n\n            if nums[mid] == target:\n                return mid\n\n            # Determine which side is sorted\n            # If left side is sorted...\n            if nums[left] &lt;= nums[mid]:\n                # Check if target is in the left sorted portion\n                if nums[left] &lt;= target &lt; nums[mid]:\n                    right = mid - 1\n                else:\n                    # Target must be in the right side\n                    left = mid + 1\n            # Otherwise, the right side is sorted\n            else:\n                # Check if target is in the right sorted portion\n                if nums[mid] &lt; target &lt;= nums[right]:\n                    left = mid + 1\n                else:\n                    # Target must be in the left side\n                    right = mid - 1\n\n        return -1\n\n    def is_valid_parentheses(self, s: str) -&gt; bool:\n        \"\"\"\n        Determines if the input string has valid parentheses.\n\n        Args:\n            s: String containing '(', ')', '{', '}', '[', ']'.\n\n        Returns:\n            True if the parentheses are valid, False otherwise.\n        \"\"\"\n        stack: list[str] = []\n        mapping = {\")\": \"(\", \"}\": \"{\", \"]\": \"[\"}\n\n        for char in s:\n            if char in mapping:\n                # Closing bracket: check if matches top of stack\n                top_element = stack.pop() if stack else \"#\"\n                if mapping[char] != top_element:\n                    return False\n            else:\n                # Opening bracket: push to stack\n                stack.append(char)\n\n        # If stack is empty, all brackets were matched\n        return not stack\n\n    def ladder_length(self, begin_word: str, end_word: str, word_list: list[str]) -&gt; int:\n        \"\"\"\n        Finds the length of the shortest transformation sequence from begin_word to end_word.\n\n        Args:\n            begin_word: The starting word.\n            end_word: The target word.\n            word_list: List of available words for transformation.\n\n        Returns:\n            The number of words in the shortest sequence (including begin_word).\n            Returns 0 if no such sequence exists.\n        \"\"\"\n        word_set = set(word_list)\n        if end_word not in word_set:\n            return 0\n\n        # BFS Queue: stores (current_word, level)\n        queue: deque[tuple[str, int]] = deque([(begin_word, 1)])\n\n        # Visited set to prevent cycles\n        visited = {begin_word}\n\n        while queue:\n            current_word, level = queue.popleft()\n\n            if current_word == end_word:\n                return level\n\n            # Try changing each character of the word\n            for i in range(len(current_word)):\n                original_char = current_word[i]\n\n                # Check all 26 lowercase letters\n                for c in range(ord(\"a\"), ord(\"z\") + 1):\n                    char = chr(c)\n                    if char == original_char:\n                        continue\n\n                    # Create new word combination\n                    new_word = current_word[:i] + char + current_word[i + 1 :]\n\n                    if new_word in word_set and new_word not in visited:\n                        visited.add(new_word)\n                        queue.append((new_word, level + 1))\n\n        return 0\n\n    def max_area(self, height: list[int]) -&gt; int:\n        \"\"\"\n        Finds the maximum area of water a container can store.\n\n        Args:\n            height: List of non-negative integers representing wall heights.\n\n        Returns:\n            The maximum area.\n        \"\"\"\n        left, right = 0, len(height) - 1\n        max_water = 0\n\n        while left &lt; right:\n            width = right - left\n            current_height = min(height[left], height[right])\n            max_water = max(max_water, width * current_height)\n\n            if height[left] &lt; height[right]:\n                left += 1\n            else:\n                right -= 1\n\n        return max_water\n\n    def subsets_with_dup(self, nums: list[int]) -&gt; list[list[int]]:\n        \"\"\"\n        Returns all possible subsets (the power set) of a collection of integers with duplicates.\n\n        Args:\n            nums: List of integers (potentially containing duplicates).\n\n        Returns:\n            A list of all unique subsets.\n        \"\"\"\n        results: list[list[int]] = []\n        nums.sort()\n\n        def backtrack(start_index: int, current_subset: list[int]) -&gt; None:\n            results.append(list(current_subset))\n\n            for i in range(start_index, len(nums)):\n                if i &gt; start_index and nums[i] == nums[i - 1]:\n                    continue\n\n                current_subset.append(nums[i])\n                backtrack(i + 1, current_subset)\n                current_subset.pop()\n\n        backtrack(0, [])\n        return results\n\n    def min_window(self, s: str, t: str) -&gt; str:\n        \"\"\"\n        Finds the minimum window substring of s that contains all characters in t.\n\n        Args:\n            s: The source string.\n            t: The target string containing characters to be matched.\n\n        Returns:\n            The empty string \"\" if no such window exists, or the minimum window.\n        \"\"\"\n        if not t or not s:\n            return \"\"\n\n        # Dictionary to keep a count of all the unique characters in t.\n        dict_t: dict[str, int] = {}\n        for char in t:\n            dict_t[char] = dict_t.get(char, 0) + 1\n\n        required = len(dict_t)\n\n        # Filter all the characters from s into a new list along with their index.\n        # The filtering criteria is that the character should be present in t.\n        # (Optimization not strictly necessary but helpful for sparse s).\n        # We'll stick to standard sliding window for clarity.\n\n        left, r = 0, 0\n\n        # formed is used to keep track of how many unique characters in t\n        # are present in the current window in its desired frequency.\n        formed = 0\n        window_counts: dict[str, int] = {}\n\n        # ans tuple of the form (window length, left, right)\n        ans = float(\"inf\"), None, None\n\n        while r &lt; len(s):\n            # Add one character from the right to the window\n            character = s[r]\n            window_counts[character] = window_counts.get(character, 0) + 1\n\n            # If the frequency of the current character added equals to the\n            # desired count in t then increment the formed count by 1.\n            if character in dict_t and window_counts[character] == dict_t[character]:\n                formed += 1\n\n            # Try and contract the window till the point where it ceases to be 'desirable'.\n            while left &lt;= r and formed == required:\n                character = s[left]\n\n                # Save the smallest window until now.\n                if r - left + 1 &lt; ans[0]:\n                    ans = (r - left + 1, left, r)\n\n                # The character at the position pointed by the\n                # `left` pointer is no longer a part of the window.\n                window_counts[character] -= 1\n                if character in dict_t and window_counts[character] &lt; dict_t[character]:\n                    formed -= 1\n\n                # Move the left pointer ahead, this would help to look for a new window.\n                left += 1\n\n            # Keep expanding the window once we are done contracting.\n            r += 1\n\n        return \"\" if ans[0] == float(\"inf\") else s[ans[1] : ans[2] + 1]\n\n    def reverse_k_group(self, head: ListNode | None, k: int) -&gt; ListNode | None:\n        \"\"\"\n        Reverses nodes of a linked list k at a time.\n\n        Args:\n            head: The head of the linked list.\n            k: The size of the group to reverse.\n\n        Returns:\n            The head of the modified linked list.\n        \"\"\"\n        if not head or k == 1:\n            return head\n\n        # Check if there are at least k nodes left\n        curr = head\n        count = 0\n        while curr and count &lt; k:\n            curr = curr.next\n            count += 1\n\n        if count &lt; k:\n            return head\n\n        # Reverse k nodes\n        prev = None\n        curr = head\n        for _ in range(k):\n            next_node = curr.next\n            curr.next = prev\n            prev = curr\n            curr = next_node\n\n        # Recursive call for the rest of the list\n        # head is now the tail of the reversed group, so head.next should point\n        # to the result of recursion on the rest\n        if head:\n            head.next = self.reverse_k_group(curr, k)\n\n        return prev\n\n    def find_min(self, nums: list[int]) -&gt; int:\n        \"\"\"\n        Finds the minimum element in a rotated sorted array.\n\n        Args:\n            nums: The rotated sorted array.\n\n        Returns:\n            The minimum value.\n        \"\"\"\n        left, right = 0, len(nums) - 1\n\n        # If the array is not rotated (or we found the sorted segment)\n        if nums[left] &lt;= nums[right]:\n            return nums[left]\n\n        while left &lt; right:\n            mid = (left + right) // 2\n\n            # If mid element is greater than right element,\n            # the minimum must be to the right of mid\n            if nums[mid] &gt; nums[right]:\n                left = mid + 1\n            else:\n                # Otherwise, the minimum is at mid or to the left\n                right = mid\n\n        return nums[left]\n\n\nclass MedianFinder:\n    \"\"\"\n    MedianFinder class to find the median from a data stream.\n    \"\"\"\n\n    def __init__(self):\n        \"\"\"\n        Initializes the MedianFinder object.\n        \"\"\"\n        # Max-heap to store the smaller half of the numbers\n        # We invert values to simulate max-heap with Python's min-heap\n        self.small = []\n        # Min-heap to store the larger half of the numbers\n        self.large = []\n\n    def add_num(self, num: int) -&gt; None:\n        \"\"\"\n        Adds the integer num from the data stream to the data structure.\n        \"\"\"\n        # Allow small heap to grow first\n        heapq.heappush(self.small, -num)\n\n        # Ensure every element in small is &lt;= every element in large\n        if self.small and self.large and (-self.small[0] &gt; self.large[0]):\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n\n        # Balance sizes: small can have at most 1 more element than large\n        if len(self.small) &gt; len(self.large) + 1:\n            val = -heapq.heappop(self.small)\n            heapq.heappush(self.large, val)\n        if len(self.large) &gt; len(self.small):\n            val = heapq.heappop(self.large)\n            heapq.heappush(self.small, -val)\n\n    def find_median(self) -&gt; float:\n        \"\"\"\n        Returns the median of all elements so far.\n        \"\"\"\n        if len(self.small) &gt; len(self.large):\n            return float(-self.small[0])\n        return (-self.small[0] + self.large[0]) / 2.0\n</code></pre>"},{"location":"source_code/microsoft/","title":"Microsoft Source Code","text":"<pre><code>import heapq\nfrom collections import Counter, deque\n\nfrom src.data_structures import ListNode, TreeNode\n\n\nclass MicrosoftSolutions:\n    \"\"\"\n    Solutions for Microsoft DSA problems.\n    \"\"\"\n\n    # --- Master List (topics.md) Problems 1-9 ---\n\n    def largest_rectangle_area(self, heights: list[int]) -&gt; int:\n        \"\"\"\n        Largest Rectangle in Histogram: Returns area of largest rectangle.\n        \"\"\"\n        stack = [-1]\n        max_area = 0\n        for i, h in enumerate(heights):\n            while stack[-1] != -1 and heights[stack[-1]] &gt;= h:\n                curr_h = heights[stack.pop()]\n                curr_w = i - stack[-1] - 1\n                max_area = max(max_area, curr_h * curr_w)\n            stack.append(i)\n\n        while stack[-1] != -1:\n            curr_h = heights[stack.pop()]\n            curr_w = len(heights) - stack[-1] - 1\n            max_area = max(max_area, curr_h * curr_w)\n        return max_area\n\n    def has_cycle(self, head: ListNode | None) -&gt; bool:\n        \"\"\"\n        Linked List Cycle: Determines if a list has a cycle using Floyd's.\n        \"\"\"\n        slow = fast = head\n        while fast and fast.next:\n            slow = slow.next\n            fast = fast.next.next\n            if slow == fast:\n                return True\n        return False\n\n    def group_anagrams(self, strs: list[str]) -&gt; list[list[str]]:\n        \"\"\"\n        Group Anagrams: Groups strings that are anagrams of each other.\n        \"\"\"\n        anagrams = {}\n        for s in strs:\n            key = \"\".join(sorted(s))\n            anagrams.setdefault(key, []).append(s)\n        return list(anagrams.values())\n\n    def letter_combinations(self, digits: str) -&gt; list[str]:\n        \"\"\"\n        Letter Combinations of a Phone Number: Returns all possible letter strings.\n        \"\"\"\n        if not digits:\n            return []\n        digit_map = {\n            \"2\": \"abc\",\n            \"3\": \"def\",\n            \"4\": \"ghi\",\n            \"5\": \"jkl\",\n            \"6\": \"mno\",\n            \"7\": \"pqrs\",\n            \"8\": \"tuv\",\n            \"9\": \"wxyz\",\n        }\n        res = []\n\n        def backtrack(index, path):\n            if index == len(digits):\n                res.append(\"\".join(path))\n                return\n            for char in digit_map[digits[index]]:\n                path.append(char)\n                backtrack(index + 1, path)\n                path.pop()\n\n        backtrack(0, [])\n        return res\n\n    def is_valid_sudoku(self, board: list[list[str]]) -&gt; bool:\n        \"\"\"\n        Valid Sudoku: Validates a 9x9 Sudoku board.\n        \"\"\"\n        rows = [set() for _ in range(9)]\n        cols = [set() for _ in range(9)]\n        boxes = [set() for _ in range(9)]\n\n        for r in range(9):\n            for c in range(9):\n                val = board[r][c]\n                if val == \".\":\n                    continue\n                box_idx = (r // 3) * 3 + (c // 3)\n                if val in rows[r] or val in cols[c] or val in boxes[box_idx]:\n                    return False\n                rows[r].add(val)\n                cols[c].add(val)\n                boxes[box_idx].add(val)\n        return True\n\n    def word_search(self, board: list[list[str]], word: str) -&gt; bool:\n        \"\"\"\n        Word Search: Finds if word exists in grid.\n        \"\"\"\n        rows, cols = len(board), len(board[0])\n\n        def dfs(r, c, k):\n            if k == len(word):\n                return True\n            if r &lt; 0 or r &gt;= rows or c &lt; 0 or c &gt;= cols or board[r][c] != word[k]:\n                return False\n            temp = board[r][c]\n            board[r][c] = \"#\"  # Visited\n            res = (\n                dfs(r + 1, c, k + 1)\n                or dfs(r - 1, c, k + 1)\n                or dfs(r, c + 1, k + 1)\n                or dfs(r, c - 1, k + 1)\n            )\n            board[r][c] = temp\n            return res\n\n        for r in range(rows):\n            for c in range(cols):\n                if dfs(r, c, 0):\n                    return True\n        return False\n\n    def min_depth(self, root: TreeNode | None) -&gt; int:\n        \"\"\"\n        Minimum Depth of Binary Tree: Returns shortest path to leaf.\n        \"\"\"\n        if not root:\n            return 0\n        if not root.left:\n            return self.min_depth(root.right) + 1\n        if not root.right:\n            return self.min_depth(root.left) + 1\n        return min(self.min_depth(root.left), self.min_depth(root.right)) + 1\n\n    def rotate_array(self, nums: list[int], k: int) -&gt; None:\n        \"\"\"\n        Rotate Array: Rotates array to the right by k steps in-place.\n        \"\"\"\n        n = len(nums)\n        k %= n\n\n        def reverse(left, right):\n            while left &lt; right:\n                nums[left], nums[right] = nums[right], nums[left]\n                left, right = left + 1, right - 1\n\n        reverse(0, n - 1)\n        reverse(0, k - 1)\n        reverse(k, n - 1)\n\n    def longest_palindrome(self, s: str) -&gt; str:\n        \"\"\"\n        Largest Palindromic Substring: Returns the longest palindrome.\n        \"\"\"\n        if not s:\n            return \"\"\n\n        def expand(left, right):\n            while left &gt;= 0 and right &lt; len(s) and s[left] == s[right]:\n                left -= 1\n                right += 1\n            return s[left + 1 : right]\n\n        res = \"\"\n        for i in range(len(s)):\n            p1 = expand(i, i)\n            if len(p1) &gt; len(res):\n                res = p1\n            p2 = expand(i, i + 1)\n            if len(p2) &gt; len(res):\n                res = p2\n        return res\n\n    # --- End Master List ---\n\n    def eval_rpn(self, tokens: list[str]) -&gt; int:\n        \"\"\"\n        Evaluate Reverse Polish Notation.\n        \"\"\"\n        stack: list[int] = []\n        for token in tokens:\n            if token in \"+-*/\":\n                b = stack.pop()\n                a = stack.pop()\n                if token == \"+\":\n                    stack.append(a + b)\n                elif token == \"-\":\n                    stack.append(a - b)\n                elif token == \"*\":\n                    stack.append(a * b)\n                elif token == \"/\":\n                    # Python's // floor divides, but we need truncation towards zero\n                    stack.append(int(a / b))\n            else:\n                stack.append(int(token))\n        return stack[0]\n\n    def combination_sum_3(self, k: int, n: int) -&gt; list[list[int]]:\n        \"\"\"\n        Find all valid combinations of k numbers that sum up to n.\n        \"\"\"\n        results = []\n\n        def backtrack(start: int, current_comb: list[int], current_sum: int):\n            if len(current_comb) == k:\n                if current_sum == n:\n                    results.append(list(current_comb))\n                return\n\n            if current_sum &gt; n:\n                return\n\n            for i in range(start, 10):\n                current_comb.append(i)\n                backtrack(i + 1, current_comb, current_sum + i)\n                current_comb.pop()\n\n        backtrack(1, [], 0)\n        return results\n\n    def get_hint(self, secret: str, guess: str) -&gt; str:\n        \"\"\"\n        Bulls and Cows game hint.\n        \"\"\"\n        bulls = 0\n        cows = 0\n        secret_counts = Counter(secret)\n        guess_counts = Counter(guess)\n\n        # Calculate Bulls\n        for s, g in zip(secret, guess, strict=False):\n            if s == g:\n                bulls += 1\n                # Decrement counts for bulls so they aren't counted as cows\n                secret_counts[s] -= 1\n                guess_counts[g] -= 1\n\n        # Calculate Cows\n        for char, count in guess_counts.items():\n            if char in secret_counts:\n                # Cows is min of remaining available in secret vs guess\n                cows += min(count, secret_counts[char])\n\n        return f\"{bulls}A{cows}B\"\n\n    def rotate_function(self, nums: list[int]) -&gt; int:\n        \"\"\"\n        Calculate maximum value of F(k) for rotation function.\n        F(k) = 0*arr[0] + 1*arr[1] + ... + (n-1)*arr[n-1]\n        \"\"\"\n        n = len(nums)\n        s = sum(nums)\n        f_0 = sum(i * num for i, num in enumerate(nums))\n\n        max_f = f_0\n        current_f = f_0\n\n        # F(k) = F(k-1) + sum - n * nums[n-k]\n        # Iterate k from 1 to n-1\n        # The element moving from end to start is nums[n-k]\n        for k in range(1, n):\n            current_f = current_f + s - n * nums[n - k]\n            max_f = max(max_f, current_f)\n\n        return max_f\n\n    def largest_divisible_subset(self, nums: list[int]) -&gt; list[int]:\n        \"\"\"\n        Returns largest subset where every pair (a, b) satisfies a % b == 0 or b % a == 0.\n        \"\"\"\n        if not nums:\n            return []\n        nums.sort()\n        n = len(nums)\n        # dp[i] stores the size of largest divisible subset ending at index i\n        dp = [1] * n\n        # prev[i] stores the index of the previous element in the subset\n        prev = [-1] * n\n\n        max_size = 1\n        max_index = 0\n\n        for i in range(1, n):\n            for j in range(i):\n                if nums[i] % nums[j] == 0 and dp[i] &lt; dp[j] + 1:\n                    dp[i] = dp[j] + 1\n                    prev[i] = j\n\n            if dp[i] &gt; max_size:\n                max_size = dp[i]\n                max_index = i\n\n        # Reconstruct path\n        result = []\n        curr = max_index\n        while curr != -1:\n            result.append(nums[curr])\n            curr = prev[curr]\n\n        return result[::-1]\n\n    def is_rectangle_cover(self, rectangles: list[list[int]]) -&gt; bool:\n        \"\"\"\n        Check if all rectangles form an exact cover of a rectangular region.\n        \"\"\"\n        area = 0\n        corners = set()\n        min_x, min_y = float(\"inf\"), float(\"inf\")\n        max_x, max_y = float(\"-inf\"), float(\"-inf\")\n\n        for x1, y1, x2, y2 in rectangles:\n            area += (x2 - x1) * (y2 - y1)\n            min_x = min(min_x, x1)\n            min_y = min(min_y, y1)\n            max_x = max(max_x, x2)\n            max_y = max(max_y, y2)\n\n            # XOR corners to cancel out internal overlaps\n            # A corner is internal if it appears 2 or 4 times.\n            # It's an outer corner if it appears 1 time (or 3, but 3 implies overlap/error usually).\n            # We track \"presence\" with set logic:\n            # if in set, remove it (even count), else add (odd count).\n            # Actually proper way: count occurrences. But efficient way:\n            current_corners = {(x1, y1), (x1, y2), (x2, y1), (x2, y2)}\n            for c in current_corners:\n                if c in corners:\n                    corners.remove(c)\n                else:\n                    corners.add(c)\n\n        # Check 1: Area match\n        if area != (max_x - min_x) * (max_y - min_y):\n            return False\n\n        # Check 2: Exact 4 corners remaining\n        if len(corners) != 4:\n            return False\n\n        # Check 3: The 4 corners must be the bounding box corners\n        return corners == {(min_x, min_y), (min_x, max_y), (max_x, min_y), (max_x, max_y)}\n\n    def can_finish(self, num_courses: int, prerequisites: list[list[int]]) -&gt; bool:\n        \"\"\"\n        Course Schedule: Detect cycle in directed graph.\n        \"\"\"\n        adj = [[] for _ in range(num_courses)]\n        for course, pre in prerequisites:\n            adj[pre].append(course)\n\n        # 0: unvisited, 1: visiting (current path), 2: visited (safe)\n        state = [0] * num_courses\n\n        def has_cycle(node):\n            if state[node] == 1:\n                return True\n            if state[node] == 2:\n                return False\n\n            state[node] = 1\n            for neighbor in adj[node]:\n                if has_cycle(neighbor):\n                    return True\n            state[node] = 2\n            return False\n\n        return all(not has_cycle(i) for i in range(num_courses))\n\n    def most_profitable_path(self, edges: list[list[int]], bob: int, amount: list[int]) -&gt; int:\n        \"\"\"\n        Find max net income for Alice traveling from 0 to leaf. Bob travels from 'bob' to 0.\n        \"\"\"\n        n = len(amount)\n        adj = [[] for _ in range(n)]\n        for u, v in edges:\n            adj[u].append(v)\n            adj[v].append(u)\n\n        # 1. Find Bob's path and arrival times\n        bob_time = {}  # node -&gt; time\n        visited = [False] * n\n        visited[bob] = True\n\n        # DFS to find path from Bob to 0 to record times\n        # Actually DFS is better to map the exact path\n        def find_bob_path(node, time):\n            bob_time[node] = time\n            if node == 0:\n                return True\n\n            for neighbor in adj[node]:\n                if neighbor not in bob_time and find_bob_path(neighbor, time + 1):\n                    return True\n            del bob_time[node]\n            return False\n\n        find_bob_path(bob, 0)\n\n        # 2. DFS for Alice\n        max_profit = float(\"-inf\")\n        visited = [False] * n\n\n        def alice_dfs(node, time, current_profit):\n            nonlocal max_profit\n            visited[node] = True\n\n            # Calculate profit at this node\n            node_profit = 0\n            if node not in bob_time or time &lt; bob_time[node]:\n                node_profit = amount[node]\n            elif time == bob_time[node]:\n                node_profit = amount[node] // 2\n            else:\n                node_profit = 0\n\n            current_profit += node_profit\n\n            # Leaf check (excluding root unless it is isolated)\n            is_leaf = True\n            for neighbor in adj[node]:\n                if not visited[neighbor]:\n                    is_leaf = False\n                    alice_dfs(neighbor, time + 1, current_profit)\n\n            if is_leaf:\n                max_profit = max(max_profit, current_profit)\n\n        alice_dfs(0, 0, 0)\n        return int(max_profit)\n\n    def number_of_pairs(self, nums1: list[int], nums2: list[int], diff: int) -&gt; int:\n        \"\"\"\n        Count pairs (i, j) where i &lt; j and nums1[i] - nums1[j] &lt;= nums2[i] - nums2[j] + diff.\n        Equivalent to: (nums1[i] - nums2[i]) &lt;= (nums1[j] - nums2[j]) + diff.\n        Let d[k] = nums1[k] - nums2[k]. Find i &lt; j such that d[i] &lt;= d[j] + diff.\n        \"\"\"\n        d = [n1 - n2 for n1, n2 in zip(nums1, nums2, strict=False)]\n\n        # Use Merge Sort to count valid pairs\n        def merge_sort(arr):\n            if len(arr) &lt;= 1:\n                return arr, 0\n\n            mid = len(arr) // 2\n            left, left_count = merge_sort(arr[:mid])\n            right, right_count = merge_sort(arr[mid:])\n\n            count = left_count + right_count\n\n            # Count pairs\n            # For each x in left, find how many y in right satisfy x &lt;= y + diff  =&gt;  x - diff &lt;= y\n            # Since right is sorted, we can use two pointers or bisect\n            r_idx = 0\n            for x in left:\n                while r_idx &lt; len(right) and right[r_idx] &lt; x - diff:\n                    r_idx += 1\n                # All elements from r_idx onwards satisfy right[k] &gt;= x - diff\n                count += len(right) - r_idx\n\n            # Merge\n            sorted_arr = []\n            i = j = 0\n            while i &lt; len(left) and j &lt; len(right):\n                if left[i] &lt;= right[j]:\n                    sorted_arr.append(left[i])\n                    i += 1\n                else:\n                    sorted_arr.append(right[j])\n                    j += 1\n            sorted_arr.extend(left[i:])\n            sorted_arr.extend(right[j:])\n\n            return sorted_arr, count\n\n        _, total_pairs = merge_sort(d)\n        return total_pairs\n\n    def find_unsorted_subarray(self, nums: list[int]) -&gt; int:\n        \"\"\"\n        Find shortest continuous subarray that if sorted sorts the whole array.\n        \"\"\"\n        n = len(nums)\n        if n &lt;= 1:\n            return 0\n\n        # Find minimum index 'start' where order breaks from left\n        start = -1\n        max_val = float(\"-inf\")\n        for i in range(n):\n            if nums[i] &lt; max_val:\n                # Assuming simple case: comparing to sorted version?\n                # Optimization: one pass logic\n                pass\n            max_val = max(max_val, nums[i])\n\n        # Simpler O(N) approach:\n        # Scan from left to find first element not matching sorted order\n        # Scan from right to find first element not matching sorted order\n        # Actually easier: Create sorted copy, compare ends. O(N log N).\n        # Optimal O(N):\n        # Find min element in the \"unsorted candidate\" range and max element.\n        # Expand bounds.\n\n        end = -2\n        start = -1\n        max_so_far = float(\"-inf\")\n\n        for i in range(n):\n            max_so_far = max(max_so_far, nums[i])\n            if nums[i] &lt; max_so_far:\n                end = i\n\n        min_so_far = float(\"inf\")\n        for i in range(n - 1, -1, -1):\n            min_so_far = min(min_so_far, nums[i])\n            if nums[i] &gt; min_so_far:\n                start = i\n\n        if end == -2:\n            return 0\n        return end - start + 1\n\n    def count_paths(self, n: int, roads: list[list[int]]) -&gt; int:\n        \"\"\"\n        Number of Ways to Arrive at Destination with min time.\n        Dijkstra + DP.\n        \"\"\"\n        import heapq\n\n        mod = 10**9 + 7\n\n        adj = [[] for _ in range(n)]\n        for u, v, t in roads:\n            adj[u].append((v, t))\n            adj[v].append((u, t))\n\n        dist = [float(\"inf\")] * n\n        ways = [0] * n\n        dist[0] = 0\n        ways[0] = 1\n\n        # (time, node)\n        pq = [(0, 0)]\n\n        while pq:\n            d, u = heapq.heappop(pq)\n\n            if d &gt; dist[u]:\n                continue\n\n            for v, time in adj[u]:\n                new_dist = d + time\n                if new_dist &lt; dist[v]:\n                    dist[v] = new_dist\n                    ways[v] = ways[u]\n                    heapq.heappush(pq, (new_dist, v))\n                elif new_dist == dist[v]:\n                    ways[v] = (ways[v] + ways[u]) % mod\n\n        return ways[n - 1]\n\n    def longest_prefix(self, s: str) -&gt; str:\n        \"\"\"\n        Longest Happy Prefix: Prefix that is also Suffix (excluding itself).\n        KMP Algorithm - LPS array last element.\n        \"\"\"\n        n = len(s)\n        lps = [0] * n\n        length = 0\n        i = 1\n\n        while i &lt; n:\n            if s[i] == s[length]:\n                length += 1\n                lps[i] = length\n                i += 1\n            else:\n                if length != 0:\n                    length = lps[length - 1]\n                else:\n                    lps[i] = 0\n                    i += 1\n\n        return s[: lps[n - 1]]\n\n    def rotate(self, matrix: list[list[int]]) -&gt; None:\n        \"\"\"\n        Rotate Image: Rotate n x n matrix 90 degrees clockwise in-place.\n        \"\"\"\n        n = len(matrix)\n\n        # 1. Transpose (swap matrix[i][j] with matrix[j][i])\n        for i in range(n):\n            for j in range(i, n):\n                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]\n\n        # 2. Reverse each row\n        for i in range(n):\n            matrix[i].reverse()\n\n    def nth_person_gets_nth_seat(self, n: int) -&gt; float:\n        \"\"\"\n        Airplane Seat Assignment: Probability nth person gets nth seat.\n        \"\"\"\n        if n == 1:\n            return 1.0\n        return 0.5\n\n    def combination_sum(self, candidates: list[int], target: int) -&gt; list[list[int]]:\n        \"\"\"\n        Finds all unique combinations in candidates where the numbers sum to target.\n        \"\"\"\n        results = []\n\n        def backtrack(remain, curr_comb, start):\n            if remain == 0:\n                results.append(list(curr_comb))\n                return\n            for i in range(start, len(candidates)):\n                if candidates[i] &lt;= remain:\n                    curr_comb.append(candidates[i])\n                    # We can reuse elements, so pass i as start\n                    backtrack(remain - candidates[i], curr_comb, i)\n                    curr_comb.pop()\n\n        candidates.sort()\n        backtrack(target, [], 0)\n        return results\n\n    def is_valid_palindrome(self, s: str) -&gt; bool:\n        \"\"\"\n        Checks if a string is a palindrome after removing non-alphanumeric chars.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        while left &lt; right:\n            while left &lt; right and not s[left].isalnum():\n                left += 1\n            while left &lt; right and not s[right].isalnum():\n                right -= 1\n            if s[left].lower() != s[right].lower():\n                return False\n            left += 1\n            right -= 1\n        return True\n\n    def delete_node(self, node: ListNode) -&gt; None:\n        \"\"\"\n        Deletes a node in a linked list given only access to that node.\n        \"\"\"\n        # Copy next node's value and skip it\n        node.val = node.next.val\n        node.next = node.next.next\n\n    def max_profit(self, prices: list[int]) -&gt; int:\n        \"\"\"\n        Best Time to Buy and Sell Stock: Finds max profit from one transaction.\n        \"\"\"\n        min_price = float(\"inf\")\n        max_profit = 0\n        for price in prices:\n            if price &lt; min_price:\n                min_price = price\n            elif price - min_price &gt; max_profit:\n                max_profit = price - min_price\n        return max_profit\n\n    def spiral_order(self, matrix: list[list[int]]) -&gt; list[int]:\n        \"\"\"\n        Spiral Matrix: Returns all elements of m x n matrix in spiral order.\n        \"\"\"\n        if not matrix:\n            return []\n        res = []\n        rows, cols = len(matrix), len(matrix[0])\n        top, bottom, left, right = 0, rows - 1, 0, cols - 1\n\n        while len(res) &lt; rows * cols:\n            # Right\n            for i in range(left, right + 1):\n                res.append(matrix[top][i])\n            top += 1\n            if top &gt; bottom:\n                break\n            # Down\n            for i in range(top, bottom + 1):\n                res.append(matrix[i][right])\n            right -= 1\n            if left &gt; right:\n                break\n            # Left\n            for i in range(right, left - 1, -1):\n                res.append(matrix[bottom][i])\n            bottom -= 1\n            if top &gt; bottom:\n                break\n            # Up\n            for i in range(bottom, top - 1, -1):\n                res.append(matrix[i][left])\n            left += 1\n        return res\n\n    def right_side_view(self, root: TreeNode | None) -&gt; list[int]:\n        \"\"\"\n        Binary Tree Right Side View: Returns values seen from the right side.\n        \"\"\"\n        if not root:\n            return []\n        result = []\n        queue = deque([root])\n        while queue:\n            level_size = len(queue)\n            for i in range(level_size):\n                node = queue.popleft()\n                if i == level_size - 1:  # Last element in current level\n                    result.append(node.val)\n                if node.left:\n                    queue.append(node.left)\n                if node.right:\n                    queue.append(node.right)\n        return result\n\n\nclass SeatManager:\n    def __init__(self, n: int):\n        self.seats = list(range(1, n + 1))\n        heapq.heapify(self.seats)\n\n    def reserve(self) -&gt; int:\n        return heapq.heappop(self.seats)\n\n    def unreserve(self, seat_number: int) -&gt; None:\n        heapq.heappush(self.seats, seat_number)\n</code></pre>"}]}